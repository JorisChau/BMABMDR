#' @export par_med
#'
par_med <- function(mod.obj) {
model.listN <- mod.obj$parsN
model.listLN <- mod.obj$parsLN
md_N <- vapply(model.listN[!is.na(model.listN)], function(x){
y <- apply(x[,-c(1)], 2, median, na.rm = TRUE)
yy <- data.frame(t(y))
names(yy) <- names(x)[-1]
return(yy)
}, data.frame(a=1,b=2,c=3,d=4,k=5,BMD=6,p1=7,p2=8,p3=9,p4=10,
is2t=11, s2=12, min_response=13, max_response=14))
mdnames_N <- vapply(model.listN[!is.na(model.listN)], function(x){
unique(x[,"ModelName"])
}, character(1))
md_N <- cbind(Model = mdnames_N, as.data.frame(t(md_N)))
md_LN <- vapply(model.listLN[!is.na(model.listLN)], function(x){
y <- apply(x[,-c(1)], 2, median, na.rm = TRUE)
yy <- data.frame(t(y))
names(yy) <- names(x)[-1]
return(yy)
}, data.frame(a=1,b=2,c=3,d=4,k=5,BMD=6,p1=7,p2=8,p3=9,p4=10,
is2t=11, s2=12, min_response=13, max_response=14))
mdnames_LN <- vapply(model.listLN[!is.na(model.listLN)], function(x){
unique(x[,"ModelName"])
}, character(1))
md_LN <- cbind(Model = mdnames_LN, as.data.frame(t(md_LN)))
ret <- rbind(md_N, md_LN)
ret2 <- do.call(cbind.data.frame,
apply(ret, 2, function(x)unlist(x),
simplify = FALSE))
return(ret2)
}
summary.BMADR(FLBMD)
mod.obj = FLBMD
type = 'continuous'
model.listN <- mod.obj$parsN
model.listLN <- mod.obj$parsLN
md_N <- vapply(model.listN[!is.na(model.listN)], function(x){
y <- apply(x[,-c(1)], 2, median, na.rm = TRUE)
yy <- data.frame(t(y))
names(yy) <- names(x)[-1]
return(yy)
}, data.frame(a=1,b=2,c=3,d=4,BMD=5,p1=6,p2=7,p3=8,p4=9,
is2t=10, s2=11, min_response=12, max_response=13))
model.listN
#### function to get the median of the needed parameters for predicted values. This is done over all
# all fitted models
#' function to get the median of the needed parameters for predicted values. This is done over all
#' fitted models
#'
#' @param mod_obj BMDBMA model object
#' @return dataframe containing parameter estimates per model
#' @export par_med
#'
par_med <- function(mod.obj, type = c('continuous', 'quantal')) {
type <- match.arg(type)
if(type == 'continuous') {
model.listN <- mod.obj$parsN
model.listLN <- mod.obj$parsLN
md_N <- vapply(model.listN[!is.na(model.listN)], function(x){
y <- apply(x[,-c(1)], 2, median, na.rm = TRUE)
yy <- data.frame(t(y))
names(yy) <- names(x)[-1]
return(yy)
}, data.frame(a=1,b=2,c=3,d=4,k=5,BMD=6,p1=7,p2=8,p3=9,p4=10,
is2t=11, s2=12, min_response=13, max_response=14))
mdnames_N <- vapply(model.listN[!is.na(model.listN)], function(x){
unique(x[,"ModelName"])
}, character(1))
md_N <- cbind(Model = mdnames_N, as.data.frame(t(md_N)))
md_LN <- vapply(model.listLN[!is.na(model.listLN)], function(x){
y <- apply(x[,-c(1)], 2, median, na.rm = TRUE)
yy <- data.frame(t(y))
names(yy) <- names(x)[-1]
return(yy)
}, data.frame(a=1,b=2,c=3,d=4,k=5,BMD=6,p1=7,p2=8,p3=9,p4=10,
is2t=11, s2=12, min_response=13, max_response=14))
mdnames_LN <- vapply(model.listLN[!is.na(model.listLN)], function(x){
unique(x[,"ModelName"])
}, character(1))
md_LN <- cbind(Model = mdnames_LN, as.data.frame(t(md_LN)))
ret <- rbind(md_N, md_LN)
} else if(type == 'quantal') {
model.listQ <- mod.obj$parsQ
md_Q <- vapply(model.listQ[!is.na(model.listQ)], function(x){
y <- apply(x[,-c(1)], 2, median, na.rm = TRUE)
yy <- data.frame(t(y))
names(yy) <- names(x)[-1]
return(yy)
}, data.frame(a=1,b=2,d=3,BMD=4,rho=0,p1=5,p2=6,p3=7))
mdnames_Q <- vapply(model.listQ[!is.na(model.listQ)], function(x){
unique(x[,"ModelName"])
}, character(1))
md_Q <- cbind(Model = mdnames_Q, as.data.frame(t(md_Q)))
ret <- md_Q
} else stop('supply data type to be quantal or continuous')
ret2 <- do.call(cbind.data.frame,
apply(ret, 2, function(x)unlist(x),
simplify = FALSE))
return(ret2)
}
summary.BMADR(FLBMD)
model.listN <- mod.obj$parsN
model.listLN <- mod.obj$parsLN
md_N <- vapply(model.listN[!is.na(model.listN)], function(x){
y <- apply(x[,-c(1)], 2, median, na.rm = TRUE)
yy <- data.frame(t(y))
names(yy) <- names(x)[-1]
return(yy)
}, data.frame(a=1,b=2,c=3,d=4,k=5,BMD=6,p1=7,p2=8,p3=9,p4=10,
is2t=11, s2=12, min_response=13, max_response=14))
mdnames_N <- vapply(model.listN[!is.na(model.listN)], function(x){
unique(x[,"ModelName"])
}, character(1))
md_N <- cbind(Model = mdnames_N, as.data.frame(t(md_N)))
md_N
md_LN <- vapply(model.listLN[!is.na(model.listLN)], function(x){
y <- apply(x[,-c(1)], 2, median, na.rm = TRUE)
yy <- data.frame(t(y))
names(yy) <- names(x)[-1]
return(yy)
}, data.frame(a=1,b=2,c=3,d=4,k=5,BMD=6,p1=7,p2=8,p3=9,p4=10,
is2t=11, s2=12, min_response=13, max_response=14))
mdnames_LN <- vapply(model.listLN[!is.na(model.listLN)], function(x){
unique(x[,"ModelName"])
}, character(1))
md_LN <- cbind(Model = mdnames_LN, as.data.frame(t(md_LN)))
md_LN
# plot output
pFLBMD = plot.BMADR(FLBMD, weight_type = "LP", include_data = T, all = F, title = '')
# plot prior vs posterior
plot_prior(FLBMD, data_N$data, "E4_N", parms = T)
plot_prior(FLBMD, data_N$data, "E4_N", parms = F)
SBMD = sampling_MA(data_N, data_LN,
prior.weights,
ndraws=ndr, nrchains=nrch,
nriterations=nriter, warmup=wu, delta=dl,
treedepth=trd, seed=sd, pvec=pvec,
plot=F)
prior.weights = c(rep(1,4), rep(0,4), rep(1,4), rep(0,4))
SBMD = sampling_MA(data_N, data_LN,
prior.weights,
ndraws=ndr, nrchains=nrch,
nriterations=nriter, warmup=wu, delta=dl,
treedepth=trd, seed=sd, pvec=pvec,
plot=F)
# MA estimates
SBMD$MA_bridge_sampling
SBMD$MA_laplace
# convergence & divergence
SBMD$convergence
SBMD$divergences*100 # percentage of iterations that were divergent
# model-specific fit
SBMD$E4_N
# test whether best-fitting model fits wel (BF < 10 means equally well as saturated model; BF > 10 means best fit is better than saturated model)
SBMD$bf
# output as dataframe/list
BMDWeights(SBMD)
summary.BMADR(SBMD)
# plot output
pSBMD = plot.BMADR(SBMD, weight_type = "BS", include_data = T, all = F, title = '')
# plot prior vs posterior
plot_prior(SBMD, data_N$data, "E4_N", parms = T)
plot_prior(SBMD, data_LN$data, "P4_LN", parms = T)
dose = c(0, 5, 15, 50, 100)
y = c(0, 4, 6, 5, 12)
n = c(20, 20, 20, 20, 20)
summ.data = data.frame(x = dose, y = y, n = n)
# sampling specification
ndr=30000
nrch=3;nriter=3000;wu=1000;dl=0.8;trd=10;sd=123
# prior model weights
prior.weights = rep(1,8)
# bmr
q = 0.1
pvec = c(0.05,0.5,0.95)
# uninformative
data_Q = PREP_DATA_QA(summ.data,
sumstats = T,
q = q)
FLBMD_Q = full.laplaceQ_MA(data_Q,
prior.weights,
ndraws=ndr,
seed=123,
pvec=pvec)
# MA estimates
FLBMD_Q$MA
prior.weights
# MA estimates
FLBMD_Q$MA
# model weights
round(FLBMD_Q$weights,4)
# model-specific fit
FLBMD_Q$E4_Q
# test whether best-fitting model fits wel (BF < 10 means equally well as saturated model; BF > 10 means best fit is better than saturated model)
FLBMD_Q$bf
# output as dataframe/list
BMDWeights(FLBMD_Q)
summary.BMADR(FLBMD_Q)
# output as dataframe/list
BMDWeightsQ(FLBMD_Q)
# output as dataframe/list
BMDWeights(FLBMD_Q,'quantal')
# output as dataframe/list
BMDWeights(FLBMD,'continuous')
# output as dataframe/list
BMDWeights(FLBMD_Q, 'quantal')
summary.BMADR(FLBMD_Q, 'quantal')
summary.BMADRQ(FLBMD_Q)
# plot output
pFLBMD_Q = plot.BMADRQ(FLBMD_Q, weight_type = "LP", include_data = T, all = F, title = '')
pFLBMD_Q$BMDs
pFLBMD_Q$weights
pFLBMD_Q$model_fit
pFLBMD_Q$MA_fit
# plot prior vs posterior
plot_priorQ(FLBMD_Q, data_Q$data, "E4_Q")
plot_priorQ(FLBMD_Q, data_Q$data, "P4_Q")
plot_priorQ(FLBMD_Q, data_Q$data, "L4_Q")
SBMD_Q = samplingQ_MA(data_Q,
prior.weights,
ndraws=ndr, nrchains=nrch,
nriterations=nriter, warmup=wu, delta=dl,
treedepth=trd, seed=sd, pvec=pvec)
warnings()
# MA estimates
SBMD_Q$MA_bridge_sampling
SBMD_Q$MA_laplace
# convergence & divergence
SBMD_Q$convergence
SBMD_Q$divergences*100 # percentage of iterations that were divergent
# output as dataframe/list
BMDWeights(SBMD_Q, 'quantal')
summary.BMADRQ(SBMD_Q)
# plot output
pSBMD_Q = plot.BMADRQ(SBMD_Q, weight_type = "BS", include_data = T, all = F, title = '')
pSBMD_Q$BMDs
pSBMD_Q$weights
pSBMD_Q$model_fit
pSBMD_Q$MA_fit
# plot prior vs posterior
plot_priorQ(SBMD_Q, data_Q$data, "E4_Q")
dose = c(0,6.25,12.5,25,50,100)
mean = c(10.87143,10.16669,10.81050,10.41179,12.38305,18.47681)
sd = c(1.804554,1.805939,3.858265,1.626007,2.045695,2.322449)
n = rep(10,6)
summ.data = data.frame(x = dose, y = mean, s = sd, n = n)
plot(summ.data$x, summ.data$y, type = 'l')
# Test for dose-response effect
anydoseresponseN(summ.data$x, summ.data$y, summ.data$s, summ.data$n) # normal distribution
anydoseresponseLN(summ.data$x, summ.data$y, summ.data$s, summ.data$n) # lognormal distribution
# sampling specification
ndr=30000
nrch=3;nriter=3000;wu=1000;dl=0.8;trd=10;sd=123
# prior model weights
prior.weights = c(rep(1,8), rep(1,8))
# bmr
q = 0.1
pvec = c(0.05,0.5,0.95)
# uninformative
data_N = PREP_DATA_N(summ.data,
sumstats = T,
q = q)
data_LN = PREP_DATA_LN(summ.data,
sumstats = T,
q = q)
FLBMD=full.laplace_MA(data_N,
data_LN,
prior.weights,
ndraws=ndr,
seed=123,
pvec=pvec,
plot=F)
# MA estimates
FLBMD$MA
# model weights
round(FLBMD$weights,4)
# model-specific fit
FLBMD$E4_N
# test whether best-fitting model fits wel (BF < 10 means equally well as saturated model; BF > 10 means best fit is better than saturated model)
FLBMD$bf
# output as dataframe/list
BMDWeights(FLBMD, 'continuous')
summary.BMADR(FLBMD)
# plot output
pFLBMD = plot.BMADR(FLBMD, weight_type = "LP", include_data = T, all = F, title = '')
# plot prior vs posterior
plot_prior(FLBMD, data_N$data, "E4_N", parms = T)
SBMD = sampling_MA(data_N, data_LN,
prior.weights,
ndraws=ndr, nrchains=nrch,
nriterations=nriter, warmup=wu, delta=dl,
treedepth=trd, seed=sd, pvec=pvec,
plot=F)
warnings()
# MA estimates
SBMD$MA_bridge_sampling
SBMD$MA_laplace
# convergence & divergence
SBMD$convergence
SBMD$divergences*100 # percentage of iterations that were divergent
# model-specific fit
SBMD$E4_N
# test whether best-fitting model fits wel (BF < 10 means equally well as saturated model; BF > 10 means best fit is better than saturated model)
SBMD$bf
# output as dataframe/list
BMDWeights(SBMD, 'continuous')
summary.BMADR(SBMD)
# plot output
pSBMD = plot.BMADR(SBMD, weight_type = "BS", include_data = T, all = F, title = '')
library('rstantools')
library('usethis')
library('roxygen2')
# Set working directory to the new package directory
setwd('C:\\Users\\lucp9385\\Documents\\GitHub\\BMABMDR')
list.files(all.files=T)
Sys.getenv("BINPREF") # should be "C:/rtools40/mingw64/bin/"
Sys.setenv(BINPREF = "C:/Rtools/mingw_64/bin/")
old_path <- Sys.getenv("PATH")
# new_path <- paste("C:/Rtools/usr/bin", old_path, sep=";")
new_path <- paste(old_path, "C:\\Rtools\\mingw_32\\bin", sep=";")
new_path
Sys.setenv(PATH = new_path)
## Compile package and generate the documentation
example(source)
try(roxygen2::roxygenize(load_code = sourceDir), silent = TRUE)
rstan_config() # recompile stan models
pkgbuild::compile_dll()
roxygen2::roxygenize() # generate documentation
# devtools::reload()
devtools::build() # build source package
library(BMABMDR)
library(gamlss)
## available models?
get_models('continuous')
get_models('quantal')
dose = c(0,6.25,12.5,25,50,100)
mean = c(10.87143,10.16669,10.81050,10.41179,12.38305,18.47681)
sd = c(1.804554,1.805939,3.858265,1.626007,2.045695,2.322449)
n = rep(10,6)
summ.data = data.frame(x = dose, y = mean, s = sd, n = n)
plot(summ.data$x, summ.data$y, type = 'l')
# Test for dose-response effect
anydoseresponseN(summ.data$x, summ.data$y, summ.data$s, summ.data$n) # normal distribution
anydoseresponseLN(summ.data$x, summ.data$y, summ.data$s, summ.data$n) # lognormal distribution
# sampling specification
ndr=30000
nrch=3;nriter=3000;wu=1000;dl=0.8;trd=10;sd=123
# prior model weights
prior.weights = c(rep(1,8), rep(1,8))
# bmr
q = 0.1
pvec = c(0.05,0.5,0.95)
# uninformative
data_N = PREP_DATA_N(summ.data,
sumstats = T,
q = q)
data_LN = PREP_DATA_LN(summ.data,
sumstats = T,
q = q)
FLBMD=full.laplace_MA(data_N,
data_LN,
prior.weights,
ndraws=ndr,
seed=123,
pvec=pvec,
plot=F)
# MA estimates
FLBMD$MA
# model weights
round(FLBMD$weights,4)
# model-specific fit
FLBMD$E4_N
# test whether best-fitting model fits wel (BF < 10 means equally well as saturated model; BF > 10 means best fit is better than saturated model)
FLBMD$bf
# output as dataframe/list
BMDWeights(FLBMD, 'continuous')
summary.BMADR(FLBMD)
# plot output
pFLBMD = plot.BMADR(FLBMD, weight_type = "LP", include_data = T, all = F, title = '')
pFLBMD$BMDs
pFLBMD$weights
pFLBMD$model_fit_N
pFLBMD$model_fit_LN
pFLBMD$model_fit
pFLBMD$MA_fit
# plot prior vs posterior
plot_prior(FLBMD, data_N$data, "E4_N", parms = T)
plot_prior(FLBMD, data_N$data, "E4_N", parms = F)
plot_prior(FLBMD, data_N$data, "P4_N", parms = T)
plot_prior(FLBMD, data_LN$data, "L4_LN", parms = T)
SBMD = sampling_MA(data_N, data_LN,
prior.weights,
ndraws=ndr, nrchains=nrch,
nriterations=nriter, warmup=wu, delta=dl,
treedepth=trd, seed=sd, pvec=pvec,
plot=F)
# MA estimates
SBMD$MA_bridge_sampling
SBMD$MA_laplace
# convergence & divergence
SBMD$convergence
SBMD$divergences*100 # percentage of iterations that were divergent
# model-specific fit
SBMD$E4_N
# test whether best-fitting model fits wel (BF < 10 means equally well as saturated model; BF > 10 means best fit is better than saturated model)
SBMD$bf
# output as dataframe/list
BMDWeights(SBMD, 'continuous')
summary.BMADR(SBMD)
# plot output
pSBMD = plot.BMADR(SBMD, weight_type = "BS", include_data = T, all = F, title = '')
pSBMD$BMDs
pSBMD$weights
pSBMD$model_fit_N
pSBMD$model_fit_LN
pSBMD$model_fit
pSBMD$MA_fit
# plot prior vs posterior
plot_prior(SBMD, data_N$data, "E4_N", parms = T)
plot_prior(SBMD, data_LN$data, "P4_LN", parms = T)
dose = c(0, 5, 15, 50, 100)
y = c(0, 4, 6, 5, 12)
n = c(20, 20, 20, 20, 20)
summ.data = data.frame(x = dose, y = y, n = n)
# sampling specification
ndr=30000
nrch=3;nriter=3000;wu=1000;dl=0.8;trd=10;sd=123
# prior model weights
prior.weights = rep(1,8)
# bmr
q = 0.1
pvec = c(0.05,0.5,0.95)
# uninformative
data_Q = PREP_DATA_QA(summ.data,
sumstats = T,
q = q)
FLBMD_Q = full.laplaceQ_MA(data_Q,
prior.weights,
ndraws=ndr,
seed=123,
pvec=pvec)
# MA estimates
FLBMD_Q$MA
# model weights
round(FLBMD_Q$weights,4)
# model-specific fit
FLBMD_Q$E4_Q
# test whether best-fitting model fits wel (BF < 10 means equally well as saturated model; BF > 10 means best fit is better than saturated model)
FLBMD_Q$bf
# output as dataframe/list
BMDWeights(FLBMD_Q, 'quantal')
summary.BMADRQ(FLBMD_Q)
# plot output
pFLBMD_Q = plot.BMADRQ(FLBMD_Q, weight_type = "LP", include_data = T, all = F, title = '')
pFLBMD_Q$BMDs
pFLBMD_Q$weights
pFLBMD_Q$model_fit
pFLBMD_Q$MA_fit
# plot prior vs posterior
plot_priorQ(FLBMD_Q, data_Q$data, "E4_Q")
plot_priorQ(FLBMD_Q, data_Q$data, "P4_Q")
plot_priorQ(FLBMD_Q, data_Q$data, "L4_Q")
pFLBMD_Q$model_fit
plot_priorQ(FLBMD_Q, data_Q$data, "P4_Q")
plot_priorQ(FLBMD_Q, data_Q$data, "L4_Q")
SBMD_Q = samplingQ_MA(data_Q,
prior.weights,
ndraws=ndr, nrchains=nrch,
nriterations=nriter, warmup=wu, delta=dl,
treedepth=trd, seed=sd, pvec=pvec)
warnings()
# MA estimates
SBMD_Q$MA_bridge_sampling
SBMD_Q$MA_laplace
# convergence & divergence
SBMD_Q$convergence
SBMD_Q$divergences*100 # percentage of iterations that were divergent
# output as dataframe/list
BMDWeights(SBMD_Q, 'quantal')
summary.BMADRQ(SBMD_Q)
# plot output
pSBMD_Q = plot.BMADRQ(SBMD_Q, weight_type = "BS", include_data = T, all = F, title = '')
pSBMD_Q$BMDs
pSBMD_Q$weights
pSBMD_Q$model_fit
pSBMD_Q$MA_fit
# plot prior vs posterior
plot_priorQ(SBMD_Q, data_Q$data, "E4_Q")
library('rstantools')
library('usethis')
library('roxygen2')
# Set working directory to the new package directory
setwd('C:\\Users\\lucp9385\\Documents\\GitHub\\BMABMDR')
list.files(all.files=T)
Sys.getenv("BINPREF") # should be "C:/rtools40/mingw64/bin/"
Sys.setenv(BINPREF = "C:/Rtools/mingw_64/bin/")
Sys.getenv("BINPREF") # should be "C:/rtools40/mingw64/bin/"
old_path <- Sys.getenv("PATH")
# new_path <- paste("C:/Rtools/usr/bin", old_path, sep=";")
new_path <- paste(old_path, "C:\\Rtools\\mingw_32\\bin", sep=";")
new_path
Sys.setenv(PATH = new_path)
## Compile package and generate the documentation
example(source)
try(roxygen2::roxygenize(load_code = sourceDir), silent = TRUE)
rstan_config() # recompile stan models
pkgbuild::compile_dll()
roxygen2::roxygenize() # generate documentation
# devtools::reload()
devtools::build() # build source package
