data$priorlb, data$priorub, data$shape.a, data$shape.BMD, data$shape.c,
data$truncd))
}else{w=c(w,0)}
if(prior.weights[12]>0){
DIHLN4h=det(-solve(optLN4_LNI$hessian))
DIHLN4=ifelse(DIHLN4h<0,0,DIHLN4h)
w = c(w, fun.w(DIHLN4, llLN4LN, minll, optLN4_LNI, data$priormu, data$priorSigma,
data$priorlb, data$priorub, data$shape.a, data$shape.BMD, data$shape.c,
data$truncd))
}else{w=c(w,0)}
if(prior.weights[13]>0){
DIHG4h=det(-solve(optG4_LNI$hessian))
DIHG4=ifelse(DIHG4h<0,0,DIHG4h)
w = c(w, fun.w(DIHG4, llG4LN, minll, optG4_LNI, data$priormu, data$priorSigma,
data$priorlb, data$priorub, data$shape.a, data$shape.BMD, data$shape.c,
data$truncd))
}else{w=c(w,0)}
if(prior.weights[14]>0){
DIHQE4h=det(-solve(optQE4_LNI$hessian))
DIHQE4=ifelse(DIHQE4h<0,0,DIHQE4h)
# w = c(w, fun.w(DIHQE4, llQE4LN, minll, optQE4_LNI, data$priormu, data$priorSigma,
#                data$priorlb, data$priorub, data$shape.a, data$shape.BMD, data$shape.c))
w = c(w, fun.w(DIHQE4, llQE4LN, minll, optQE4_LNI, data$priormuQ, data$priorSigmaQ,
data$priorlb, data$priorub, data$shape.a, data$shape.BMD, data$shape.c,
data$truncdQ))
}else{w=c(w,0)}
if(prior.weights[15]>0){
DIHP4h=det(-solve(optP4_LNI$hessian))
DIHP4=ifelse(DIHP4h<0,0,DIHP4h)
w = c(w, fun.w(DIHP4, llP4LN, minll, optP4_LNI, data$priormu, data$priorSigma,
data$priorlb, data$priorub, data$shape.a, data$shape.BMD, data$shape.c,
data$truncd))
}else{w=c(w,0)}
if(prior.weights[16]>0){
DIHL4h=det(-solve(optL4_LNI$hessian))
DIHL4=ifelse(DIHL4h<0,0,DIHL4h)
w = c(w, fun.w(DIHL4, llL4LN, minll, optL4_LNI, data$priormu, data$priorSigma,
data$priorlb, data$priorub, data$shape.a, data$shape.BMD, data$shape.c,
data$truncd))
}else{w=c(w,0)}
w <- ifelse(w == 'Inf' | is.na(w), 0, w)
prior.weights = prior.weights/sum(prior.weights==1)
lpw=(prior.weights*w)/sum(prior.weights*w)
}
# the model average posterior as a mixture
count=round(lpw*ndraws)
mabmd=(c(# normal
if(prior.weights[1]>0) sample(optE4_NI$theta_tilde[,2],count[1],replace=T),
if(prior.weights[2]>0) sample(optIE4_NI$theta_tilde[,2],count[2],replace=T),
if(prior.weights[3]>0) sample(optH4_NI$theta_tilde[,2],count[3],replace=T),
if(prior.weights[4]>0) sample(optLN4_NI$theta_tilde[,2],count[4],replace=T),
if(prior.weights[5]>0) sample(optG4_NI$theta_tilde[,2],count[5],replace=T),
if(prior.weights[6]>0) sample(optQE4_NI$theta_tilde[,2],count[6],replace=T),
if(prior.weights[7]>0) sample(optP4_NI$theta_tilde[,2],count[7],replace=T),
if(prior.weights[8]>0) sample(optL4_NI$theta_tilde[,2],count[8],replace=T),
# lognormal
if(prior.weights[9]>0) sample(optE4_LNI$theta_tilde[,2],count[9],replace=T),
if(prior.weights[10]>0) sample(optIE4_LNI$theta_tilde[,2],count[10],replace=T),
if(prior.weights[11]>0) sample(optH4_LNI$theta_tilde[,2],count[11],replace=T),
if(prior.weights[12]>0) sample(optLN4_LNI$theta_tilde[,2],count[12],replace=T),
if(prior.weights[13]>0) sample(optG4_LNI$theta_tilde[,2],count[13],replace=T),
if(prior.weights[14]>0) sample(optQE4_LNI$theta_tilde[,2],count[14],replace=T),
if(prior.weights[15]>0) sample(optP4_LNI$theta_tilde[,2],count[15],replace=T),
if(prior.weights[16]>0) sample(optL4_LNI$theta_tilde[,2],count[16],replace=T)
))
maci=quantile(mabmd,pvec)*data$maxD ## original scale
names(maci)=c("BMDL","BMD","BMDU")
if(TRUE %in% (mabmd > data$maxD) && data$maxD > 1){
mabmd = ifelse(mabmd > data$maxD, data$maxD, mabmd)
p.msg = 'The model averaged posterior distribution has been truncated at max(Dose)^2'
warnings('The model averaged posterior distribution has been truncated at max(Dose)^2')
}else{
p.msg = ''
}
BMDq = quantile(mabmd, seq(0,1,0.005))*data$maxD ## original scale
BMDL = c(BMDL, maci[1]); BMD = c(BMD, maci[2]); BMDU = c(BMDU, maci[3])
names(BMDL) <- c("E4_N","IE4_N","H4_N","LN4_N","G4_N","QE4_N","P4_N","L4_N","E4_LN","IE4_LN","H4_LN",
"LN4_LN","G4_LN","QE4_LN","P4_LN","L4_LN","MA")
model = c("E4_N","IE4_N","H4_N","LN4_N","G4_N","QE4_N","P4_N","L4_N","E4_LN","IE4_LN","H4_LN",
"LN4_LN","G4_LN","QE4_LN","P4_LN","L4_LN","MA")
model = as.factor(model)
weight = c(lpw[1], lpw[2], lpw[3], lpw[4], lpw[5], lpw[6], lpw[7], lpw[8],
lpw[9], lpw[10], lpw[11], lpw[12], lpw[13], lpw[14], lpw[15], lpw[16], 1)
names(lpw) = model[1:16]
### Model-averaged response per dose level
dr.MA <- c()
for(i in 1:length(data$x)){
dr.MA[i] = weighted.mean(x = c(DRM_E4_N[i],DRM_IE4_N[i],DRM_H4_N[i],DRM_LN4_N[i],DRM_G4_N[i],DRM_QE4_N[i],
DRM_P4_N[i], DRM_L4_N[i] ,
DRM_E4_LN[i], DRM_IE4_LN[i], DRM_H4_LN[i], DRM_LN4_LN[i], DRM_G4_LN[i],
DRM_QE4_LN[i], DRM_P4_LN[i],DRM_L4_LN[i]),
w = lpw,
na.rm = T)
}
## Covariances
covs = t(data.frame(
E4_N = E4covNI,
IE4_N = IE4covNI,
H4_N = H4covNI,
LN4_N = LN4covNI,
G4_N = G4covNI,
QE4_N = QE4covNI,
P4_N = P4covNI,
L4_N = L4covNI,
E4_LN = E4covLNI,
IE4_LN = IE4covLNI,
H4_LN = H4covLNI,
LN4_LN = LN4covLNI,
G4_LN = G4covLNI,
QE4_LN = QE4covLNI,
P4_LN = P4covLNI,
L4_LN = L4covLNI
))
colnames(covs) = c("b-d", "BMD-d")
corrs = t(data.frame(
E4_N = E4corrNI,
IE4_N = IE4corrNI,
H4_N = H4corrNI,
LN4_N = LN4corrNI,
G4_N = G4corrNI,
QE4_N = QE4corrNI,
P4_N = P4corrNI,
L4_N = L4corrNI,
E4_LN = E4corrLNI,
IE4_LN = IE4corrLNI,
H4_LN = H4corrLNI,
LN4_LN = LN4corrLNI,
G4_LN = G4corrLNI,
QE4_LN = QE4corrLNI,
P4_LN = P4corrLNI,
L4_LN = L4corrLNI
))
colnames(corrs) = c("b-d", "BMD-d")
modelnames = c("E4_N","IE4_N","H4_N","LN4_N","G4_N","QE4_N","P4_N","L4_N","E4_LN","IE4_LN","H4_LN","LN4_LN","G4_LN","QE4_LN","P4_LN","L4_LN")
### Some additional checks
# print(maci)
if(maci[2]/maci[1] > 20){
warning('BMD/BMDL is larger than 20')
}
if(maci[3]/maci[1] > 50){
warning('BMDU/BMDL is larger than 50')
}
if(maci[2] < (data.N$data$x[2]*data.N$data$maxD/10)){
warning('BMD is 10 times lower than the lowest non-zero dose')
}
maci
0/0
5/0
Inf/0.00001
if(maci[1] == 0){
maci[1] = 0.000000001
}
maci
if(maci[2] == 0){
maci[2] = 0.000000001
}
maci
p.msg
BMDq
BMDL = c(BMDL, maci[1]); BMD = c(BMD, maci[2]); BMDU = c(BMDU, maci[3])
BMDL
if(maci[2]/maci[1] > 20){
warning('BMD/BMDL is larger than 20')
}
maci[2]/maci[1]
if(maci[3]/maci[1] > 50){
warning('BMDU/BMDL is larger than 50')
}
if(maci[2] < (data.N$data$x[2]*data.N$data$maxD/10)){
warning('BMD is 10 times lower than the lowest non-zero dose')
}
### best fitting model vs saturated ANOVA model
best.fit = modelnames[which(weight[1:16] == max(weight[1:16]))][1]
nrchains = 3; nriterations = 3000; warmup = 1000; delta = 0.8; treedepth = 10
bfTest <- modelTest(best.fit, data.N, data.LN, get(paste0('opt', best.fit, 'I')), type = 'Laplace',
seed, ndraws, nrchains, nriterations, warmup, delta, treedepth)
best.fit
weight
bfTest <- try(modelTest(best.fit, data.N, data.LN, get(paste0('opt', best.fit, 'I')), type = 'Laplace',
seed, ndraws, nrchains, nriterations, warmup, delta, treedepth))
bfTest
class(bfTest)
function(best.fit, data.N, data.LN, stanBest, type, seed,
ndraws, nrchains, nriterations, warmup, delta, treedepth)
stanBest = get(paste0('opt', best.fit, 'I'))
type = 'Laplace'
best.fit
svSM=list(par = c(data.N$data$m[1], # background
diff(data.N$data$m), # increments
log(1/mean(data.N$data$s2))) # invsigma2
)
priorSM = list(
priormu = c(data.N$data$m[1],
diff(data.N$data$m), # increments
-2*log(1.5*mean(sqrt(data.N$data$s2)))),
priorSigma = diag(c(1, rep(1, data.N$data$N-1), 1)),
priorlb = data.N$data$priorlb[1],
priorub = c(data.N$data$priorub[1],
max(abs(diff(data.N$data$m)))*10
)
)
svSM
priorSM
data.modstanSM=list(N=data.N$data$N, n=data.N$data$n, m=data.N$data$m, s2=data.N$data$s2, shift=data.N$data$shift,
priormu=priorSM$priormu, priorSigma=priorSM$priorSigma,
priorlb=priorSM$priorlb, priorub=priorSM$priorub,
data_type=data.N$data$data_type, priorg = data.N$data$shape.a
)
all.pars.bestfit = par_extract(stanBest, model_name = best.fit)
pars.bestfit = apply(all.pars.bestfit[,c(paste0("p",1:4), "is2t")], 2, median)
stanBest
stanBest = get(paste0('opt', best.fit, 'I'))
stanBest
all.pars.bestfit = par_extract(stanBest, model_name = best.fit)
pars.bestfit = apply(all.pars.bestfit[,c(paste0("p",1:4), "is2t")], 2, median)
optSM = optimizing(stanmodels$mSM, data = data.modstanSM,
seed=as.integer(seed), draws = ndraws,
init = svSM, hessian=TRUE)
pars.SM = apply(optSM$theta_tilde[, c(paste0('a[', 1:data.N$data$N, ']'), paste0('par[', data.N$data$N+1, ']'))], 2, median, na.rm = T)
means.SM = apply(optSM$theta_tilde[, paste0('mu[', 1:data.N$data$N, ']')], 2, median, na.rm = T)
pars.SM
means.SM
llfun = paste0('llf',best.fit,'D')
llBestfitf = get(llfun)
llBestfit = llBestfitf(x = pars.bestfit, data.N$data$n, data.N$data$x, data.N$data$m, data.N$data$s2, data.N$data$q)
llBestfit
llSM = llfSM_N(pars.SM, data.N$data$n, data.N$data$x, data.N$data$m, data.N$data$s2)
llSM
llN
pars.bestfit
data.N$data$n
data.N$data$q
pars.bestfit
llBestfitf
llBestfitf(x = pars.bestfit, data.N$data$n, data.N$data$x, data.N$data$m, data.N$data$s2, data.N$data$q)
llLN4N
optLN4_NI$par[c(1,2,9,4,5)]
pars.bestfit
round(optLN4_NI$par[c(1,2,9,4,5)],4)
round(optLN4_NI$par[c(1,2,9,4,5)],6)
llfLN4_ND(optLN4_NI$par[c(1,2,9,4,5)],
nvec=data$n,
dvec=data$x,
mvec=data$m,
s2vec=data$s2,
qval=data$q)
data = data.N$data
llfLN4_ND(optLN4_NI$par[c(1,2,9,4,5)],
nvec=data$n,
dvec=data$x,
mvec=data$m,
s2vec=data$s2,
qval=data$q)
llfLN4_ND(pars.bestfit,
nvec=data$n,
dvec=data$x,
mvec=data$m,
s2vec=data$s2,
qval=data$q)
round(optLN4_NI$par[c(1,2,9,4,5)],6)
pars.bestfit
pars.bestfit[2] = 0.000107
llBestfit = llBestfitf(x = pars.bestfit, data.N$data$n, data.N$data$x, data.N$data$m, data.N$data$s2, data.N$data$q)
llBestfit
optLN4_NI$par
median(optLN4_NI$theta_tilde[,2])
head(optLN4_NI$theta_tilde)
median(optLN4_NI$theta_tilde$par2)
?extract
stanBest$par[c(1,2,9,4,5)]
apply(all.pars.bestfit[,c(paste0("p",1:4), "is2t")], 2, mean)
?optimizing
# all.pars.bestfit = par_extract(stanBest, model_name = best.fit)
# pars.bestfit = apply(all.pars.bestfit[,c(paste0("p",1:4), "is2t")], 2, median)
pars.bestfit = stanBest$par[c(1,2,9,4,5)]
optSM = optimizing(stanmodels$mSM, data = data.modstanSM,
seed=as.integer(seed), draws = ndraws,
init = svSM, hessian=TRUE)
pars.SM = apply(optSM$theta_tilde[, c(paste0('a[', 1:data.N$data$N, ']'), paste0('par[', data.N$data$N+1, ']'))], 2, median, na.rm = T)
means.SM = apply(optSM$theta_tilde[, paste0('mu[', 1:data.N$data$N, ']')], 2, median, na.rm = T)
pars.SM
means.SM
llBestfitf = get(llfun)
llBestfit = llBestfitf(x = pars.bestfit, data.N$data$n, data.N$data$x, data.N$data$m, data.N$data$s2, data.N$data$q)
llBestfit
llSM = llfSM_N(pars.SM, data.N$data$n, data.N$data$x, data.N$data$m, data.N$data$s2)
BIC.bestfit = - 2 * llBestfit + (5 * log(sum(data.N$data$n)))
BIC.SM = - 2 * llSM + ((data.N$data$N + 1) * log(sum(data.N$data$n)))
bf = exp(-0.5 * (BIC.bestfit - BIC.SM))
bf
# example(source)
# try(roxygen2::roxygenize(load_code = sourceDir), silent = TRUE)
# # roxygen2::roxygenize(load_code = sourceDir) # generate documentation
pkgbuild::compile_dll()
roxygen2::roxygenize()
FLBMD <- full.laplace_MA(data_N, data_LN)#, prior.weights = c(rep(1,4), rep(0,12)))
dose = c(1.6,3,5.5,12.3,25.9)
y = c(48,48,19,29,33)
n = c(2288,2093,907,909,691)
plot(dose,y/n)
summ.data = data.frame(x = dose, y = y, n = n)
data.Q = PREP_DATA_QA(data = summ.data, sumstats = TRUE,
q = 0.005, bkg = NULL, shape.a = 4, shape.BMD = 0.0001,
cluster = FALSE)
pw <- rep(1,8)
test_laplace <- full.laplaceQ_MA(data.Q = data.Q, prior.weights = c(rep(1,4), rep(0,4)))
test_laplace$gof_check
load("~/BBMD/FINAL CODE/TESTING/das5.rda")
# # data.input <- das5$data[das5$data$sex==1,]
data.input <- das5$data
data.input <- data.frame(dose = data.input$dose,
response = data.input$foetalweight,
litter = data.input$number)
plot(data.input$dose, data.input$response)
plot(data.input$dose, data.input$response, xlab = 'dose', ylab = 'fetal weight')
library(dplyr)
data.plot <- data.input %>%
group_by(dose, litter) %>%
summarise(mresp = mean(response))
# plot(data.plot$dose/max(data.plot$dose), data.plot$mresp, xlab = 'Dose', ylab = 'Litter mean response')
points(data.plot$dose, data.plot$mresp, pch = 15, col = 2)
data.plot2 <- data.input %>%
group_by(dose) %>%
summarise(mresp = mean(response))
# plot(data.plot$dose/max(data.plot$dose), data.plot$mresp, xlab = 'Dose', ylab = 'Litter mean response')
points(data.plot2$dose, data.plot2$mresp, pch = 18, cex = 2, col = 3)
data.input.test.DR <- data.input
# sampling specification
ndr=30000
nrch=3;nriter=3000;wu=1000;dl=0.8;trd=10;sd=123
prior.weights = c(rep(1,4), 0, rep(0,11))
q = 0.05
pvec = c(0.05,0.5,0.95)
data_N <- PREP_DATA_N_C(data.input, q, prior.d = 'N11')
data_LN <- PREP_DATA_LN_C(data.input, q, prior.d = 'N11')
FLBMD <- full.laplace_MAc(data_N, data_LN, prior.weights)
dataDir <- '~/GitHub/BMABMDR/data/'
data <- read.csv(file.path(dataDir, "example_clusteredQuantal.csv"))
orderedData <- data[,
c("dose", "y", "n", "litter")
]
argListPrep <- list(
data = orderedData,
q = 0.1,
extended = TRUE,
cluster = TRUE
)
prepData <- do.call("PREP_DATA_QA", argListPrep)
# Fit models
argListFit <- list(
data.Q = prepData,
prior.weights = rep(1,8)
)
modelFit <- do.call("full.laplaceQ_MA", argListFit)
# example(source)
# try(roxygen2::roxygenize(load_code = sourceDir), silent = TRUE)
# # roxygen2::roxygenize(load_code = sourceDir) # generate documentation
pkgbuild::compile_dll()
roxygen2::roxygenize()
modelFit <- do.call("full.laplaceQ_MA", argListFit)
modelFit$gof_check
SBMD <- sampling_MA(data_N, data_LN, prior.weights = c(rep(1,4),rep(0,12)))
# example(source)
# try(roxygen2::roxygenize(load_code = sourceDir), silent = TRUE)
# # roxygen2::roxygenize(load_code = sourceDir) # generate documentation
pkgbuild::compile_dll()
roxygen2::roxygenize()
library(BMABMDR)
SBMD <- sampling_MA(data_N, data_LN, prior.weights = c(rep(1,4),rep(0,12)))
library('rstantools')
library('usethis')
library('roxygen2')
# library(dplyr)
# ?rstan_create_package
# rstan_create_package('C:\\Users\\lucp9385\\Documents\\GitHub\\BMABMDR',
# roxygen=T, travis=T, license=T, auto_config=T)
# Set working directory to the new package directory
setwd('C:\\Users\\lucp9385\\Documents\\GitHub\\BMABMDR')
list.files(all.files=T)
# file.show('DESCRIPTION')
# file.show('Read-and-delete-me')
# file.remove('Read-and-delete-me')
## Save all Stan files in the 'inst/stan' subdirectory
# when installing the package these will be saved in the list 'stanmodels' that is used by R to function the package
## All functions to be used by R should be saved in the 'R/' directory
Sys.getenv("BINPREF") # should be "C:/Rtools/mingw64/bin/"
# Sys.setenv(BINPREF = "C:/rtools40/mingw64/bin/;C:/rtools40/mingw32/bin/")
Sys.setenv(BINPREF = "C:/rtools40/mingw64/bin/")
# Sys.setenv(BINPREF = "C:/rtools40/mingw$(WIN)/bin/")
Sys.getenv("PATH")
old_path <- Sys.getenv("PATH")
# new_path <- paste("C:\\Rtools\\usr\\bin", old_path, sep=";")
new_path <- paste(old_path, "C:\\rtools40\\mingw32\\bin;C:\\rtools40\\mingw64\\bin", sep=";")
# # new_path
Sys.setenv(PATH = new_path)
####################################################################################
####################################################################################
### Instructions for publishing a package on CRAN: https://r-pkgs.org/release.html
# https://cran.r-project.org/web/packages/rstantools/vignettes/minimal-rstan-package.html
## Compile package and generate the documentation
rstan_config() # recompile stan models
# example(source)
# try(roxygen2::roxygenize(load_code = sourceDir), silent = TRUE)
# # roxygen2::roxygenize(load_code = sourceDir) # generate documentation
pkgbuild::compile_dll()
roxygen2::roxygenize()
library(BMABMDR)
data <- read.table("~/BBMD/FINAL CODE/TESTING/test_continuous_summarised.txt", header = T)
summ.data <- data.frame(x = data$Dose, y = data$BodyWeight, s = data$SD, n = data$N)
plot(summ.data$x, summ.data$y, type = 'l')
data_N = PREP_DATA_N(summ.data, q = 0.05)#, maxy = c(150,250,300))
data_LN = PREP_DATA_LN(summ.data, q = 0.05)#, maxy = c(150, 250, 300))
FLBMD <- full.laplace_MA(data_N, data_LN)#, prior.weights = c(rep(1,4), rep(0,12)))
FLBMD$MA
SBMD <- sampling_MA(data_N, data_LN, prior.weights = c(rep(1,4),rep(0,12)))
SBMD$gof_check
dose = c(1.6,3,5.5,12.3,25.9)
y = c(48,48,19,29,33)
n = c(2288,2093,907,909,691)
plot(dose,y/n)
summ.data = data.frame(x = dose, y = y, n = n)
data.Q = PREP_DATA_QA(data = summ.data, sumstats = TRUE,
q = 0.005, bkg = NULL, shape.a = 4, shape.BMD = 0.0001,
cluster = FALSE)
pw <- rep(1,8)
test_laplace <- full.laplaceQ_MA(data.Q = data.Q, prior.weights = c(rep(1,4), rep(0,4)))
test_laplace$gof_check
load("~/BBMD/FINAL CODE/TESTING/das5.rda")
# # data.input <- das5$data[das5$data$sex==1,]
data.input <- das5$data
data.input <- data.frame(dose = data.input$dose,
response = data.input$foetalweight,
litter = data.input$number)
par = c(10.58,0.38,1.91,2)
doses <- c(0,6.25,12.5,25,50,100)/100
dim = 10 # number of observations per litter
ngroup = 20 # number of litters per dose
covmat = matrix(0.8, nrow = dim, ncol = dim) # correlation of 0.5
diag(covmat) = 1
library(mvtnorm)
sd = 2.28
covmat2 = covmat*sd^2
q = 0.1
means = DRM.E4_NI(par, doses, q)
set.seed(34545)
sim_data = c()
for(i in 1){
datmat = c()
cnt = 1
for(j in 1:length(doses)){
for(k in 1:ngroup){
datmat = rbind(datmat,
cbind(rep(doses[j], dim), rep(cnt, dim),
## CHANGE MEANS !!!
as.vector(rmvnorm(1, mean = rep(means[j], dim), sigma = covmat2))
)
)
cnt = cnt+1
}
}
sim_data = rbind(sim_data, as.vector(datmat[,3]))
}
simulated_data = data.frame(dose = rep(doses, each = dim*ngroup),
litter = rep(c(1:(ngroup*length(doses))), each = dim),
resp = sim_data[1,])
data.input <- data.frame(dose = simulated_data$dose,
response = simulated_data$resp,
litter = simulated_data$litter)
plot(data.input$dose, data.input$response)
data_N <- PREP_DATA_N_C(data.input, q, prior.d = 'N11')
data_LN <- PREP_DATA_LN_C(data.input, q, prior.d = 'N11')
SBMD <- sampling_MAc(data_N, data_LN, prior.weights = c(rep(1,2), rep(0,14)))
library('rstantools')
library('usethis')
library('roxygen2')
# library(dplyr)
# ?rstan_create_package
# rstan_create_package('C:\\Users\\lucp9385\\Documents\\GitHub\\BMABMDR',
# roxygen=T, travis=T, license=T, auto_config=T)
# Set working directory to the new package directory
setwd('C:\\Users\\lucp9385\\Documents\\GitHub\\BMABMDR')
list.files(all.files=T)
# file.show('DESCRIPTION')
# file.show('Read-and-delete-me')
# file.remove('Read-and-delete-me')
## Save all Stan files in the 'inst/stan' subdirectory
# when installing the package these will be saved in the list 'stanmodels' that is used by R to function the package
## All functions to be used by R should be saved in the 'R/' directory
Sys.getenv("BINPREF") # should be "C:/Rtools/mingw64/bin/"
# Sys.setenv(BINPREF = "C:/rtools40/mingw64/bin/;C:/rtools40/mingw32/bin/")
Sys.setenv(BINPREF = "C:/rtools40/mingw64/bin/")
# Sys.setenv(BINPREF = "C:/rtools40/mingw$(WIN)/bin/")
Sys.getenv("PATH")
old_path <- Sys.getenv("PATH")
# new_path <- paste("C:\\Rtools\\usr\\bin", old_path, sep=";")
new_path <- paste(old_path, "C:\\rtools40\\mingw32\\bin;C:\\rtools40\\mingw64\\bin", sep=";")
# # new_path
Sys.setenv(PATH = new_path)
####################################################################################
####################################################################################
### Instructions for publishing a package on CRAN: https://r-pkgs.org/release.html
# https://cran.r-project.org/web/packages/rstantools/vignettes/minimal-rstan-package.html
## Compile package and generate the documentation
rstan_config() # recompile stan models
# example(source)
# try(roxygen2::roxygenize(load_code = sourceDir), silent = TRUE)
# # roxygen2::roxygenize(load_code = sourceDir) # generate documentation
pkgbuild::compile_dll()
roxygen2::roxygenize()
#### Run test scripts
# library(testthat)
devtools::test(stop_on_failure = TRUE)
