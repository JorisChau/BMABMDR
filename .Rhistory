}
BMD.vec <- c(BMD.min, BMD.mode, BMD.max)
shape.BMD <- shape.BMD
}
nlevels_BMD <- ifelse(covariate == 'BMD_d' | covariate == 'all', nlevels, 1)
dim(bmd.sv) <- nlevels_BMD
### Parameter d
if(covariate == 'BMD_d' | covariate == 'all'){
# Default (normal) priors on k, d, Pert on a
# prvar.d=1; prmean.d=1;
# prmean.dQE4=0
if(prior.d == 'N11'){
prvar.d = rep(1, nlevels); prmean.d = rep(1, nlevels); truncd = 5
}else if(prior.d == 'EPA'){
# prvar.d = 0.5^2; prmean.d = 0.4; truncd = 10000
prvar.d = rep(0.5, nlevels); prmean.d = rep(0.4, nlevels); truncd = 10000
# prvar.d = 1; prmean.d = 1; truncd = 10000
}else if(prior.d == 'N05'){
prvar.d = rep(0.25, nlevels); prmean.d = rep(0.5, nlevels); truncd = 10000
}
# prvar.d=sqrt(0.5); prmean.d = prmean.d
prmean.dQE4 = rep(0, nlevels); prvar.dQE4 = rep(1, nlevels); truncdQ = 10000
}else{
# Default (normal) priors on k, d, Pert on a
# prvar.d=1; prmean.d=1;
# prmean.dQE4=0
if(prior.d == 'N11'){
prvar.d = 1; prmean.d = 1; truncd = 5
}else if(prior.d == 'EPA'){
# prvar.d = 0.5^2; prmean.d = 0.4; truncd = 10000
prvar.d = 0.5; prmean.d = 0.4; truncd = 10000
# prvar.d = 1; prmean.d = 1; truncd = 10000
}else if(prior.d == 'N05'){
prvar.d = 0.25; prmean.d = 0.5; truncd = 10000
}
# prvar.d=sqrt(0.5); prmean.d = prmean.d
prmean.dQE4 = 0; prvar.dQE4 = 1; truncdQ = 10000
}
nlevels_d <- ifelse(covariate == 'BMD_d' | covariate == 'all', nlevels, 1)
nlevels_b <- ifelse(covariate == 'background' | covariate == 'BMD_d' | covariate == 'all', nlevels, 1)
priormu1a <- rbind(ifelse(rep(is.vector(a.vec), nlevels), rep(a.vec[2], nlevels), a.vec[ ,2]),
ifelse(rep(is.vector(BMD.vec), nlevels), rep(BMD.vec[2], nlevels), BMD.vec[ ,2]),
ifelse(rep(length(prmean.d)>1, nlevels), prmean.d, rep(prmean.d, nlevels)),
rep(0, nlevels)) # for rho in case of beta_bin
priormu1a
a.vec
i = 2
summ.data
miny.a
minn.a
## Default range on background
miny.a[i] <- sum(y.a[dose.a == min(dose.a[covar == covar_lvls[i]]) & covar == covar_lvls[i]])
minn.a[i] <- sum(n.a[dose.a == min(dose.a[covar == covar_lvls[i]]) & covar == covar_lvls[i]])
miny.a
minn.a
source('R/fun_Data.R')
summ.data
q = 0.1
prior.weights = rep(1,8)
FLBMD <- full.laplace_MA_Q_Cov(summ.data,
sumstats = T,
q = q,
prior.d = 'N11',
extended = T,
ndraws = 30000,
seed = 123,
pvec = c(0.05, 0.5, 0.95),
prior.weights = prior.weights)
data = summ.data
if(sumstats == TRUE){
data = data[order(data[, 1]), ]
dose.a = data[, 1]
maxDose = max(dose.a)
y.a = data[, 2]
n.a = data[, 3]
N = length(dose.a)
dose.a = dose.a/maxDose
covar = data[, 4]
} else if(sumstats == FALSE){
data = data[order(data[, 1]), ]
data$dose = data[,1]
data$resp = data[,2]
data$cov = data[,3]
indiv.data <- data %>%
dplyr::group_by(dose, cov) %>%
dplyr::arrange(by_group = dose) %>%
dplyr::summarise(y.a = sum(resp, na.rm = T), n = n())
dose.a = indiv.data$dose
maxDose = max(dose.a)
y.a = indiv.data$y.a
n.a = indiv.data$n
N = length(dose.a)
dose.a = dose.a/maxDose
covar = indiv.data$cov
dose.a = dose.a/maxDose
}
original.data = data.frame(x = dose.a*maxDose,
y = y.a,
n = n.a,
cov = covar)
covar_lvls = unique(covar)
nlevels = length(unique(covar))
if(covariate == 'BMD_d' | covariate == 'none'){
# get overall background value
dose.a2 = sort(unique(dose.a))
N2 = length(dose.a2)
y.a2 = rep(NA, N2)
n.a2 = rep(NA, N2)
for(iu in (1:N2)){
y.a2[iu] = sum(y.a[dose.a == dose.a2[iu]])
n.a2[iu] = sum(n.a[dose.a == dose.a2[iu]])
}
}
## clustered data option
is_bin <- ifelse(cluster == FALSE, 1, 0)
is_betabin <- ifelse(cluster == TRUE, 1, 0)
is_informative_BMD = 0
is_informative_a = 0
miny.a <- minn.a <- a.mode <- a.min <- a.max <- numeric(nlevels)
for(i in 1:nlevels){
## Default range on background
miny.a[i] <- sum(y.a[dose.a == min(dose.a[covar == covar_lvls[i]]) & covar == covar_lvls[i]])
minn.a[i] <- sum(n.a[dose.a == min(dose.a[covar == covar_lvls[i]]) & covar == covar_lvls[i]])
}
miny.a
minn.a
for(i in 1:nlevels){
a.min[i] <- ifelse(miny.a[i] != 0,
max(c(prop.test(miny.a[i], minn.a[i])$conf.int[1]/2, 1/(10*minn.a[i]))),
.Machine$double.xmin)
a.max[i] <- min(c(3*prop.test(miny.a[1], minn.a[1])$conf.int[2]/2, 1 - 1/(10*minn.a[i])))
a.mode[i] <- max(c(miny.a[i]/minn.a[i], 1/(5*minn.a[i])))
}
a.min
a.max
a.mode
## If info on background is given (STILL HAS TO BE IMPLEMENTED FOR COVARIATE EFFECT)
if(!is.null(bkg)){
# is_informative_a = 1
if(!is.na(bkg[2])){
a.mode = bkg[2]
}
if(!is.na(bkg[1])){
a.min = bkg[1]
}
if(!is.na(bkg[3])){
a.max = bkg[3]
}
is_informative_a = 1
}else {
message("Default prior choices used on background")
}
# Prior on a
a.vec = matrix(c(a.min, a.mode, a.max), nrow = nlevels, ncol = 3)
shape.a = rep(shape.a, nlevels)
a.vec
sum(y.a2[dose.a == min(dose.a)])
# get overall background value
dose.a2 = sort(unique(dose.a))
N2 = length(dose.a2)
y.a2 = rep(NA, N2)
n.a2 = rep(NA, N2)
for(iu in (1:N2)){
y.a2[iu] = sum(y.a[dose.a == dose.a2[iu]])
n.a2[iu] = sum(n.a[dose.a == dose.a2[iu]])
}
sum(y.a2[dose.a == min(dose.a)])
sum(n.a2[dose.a == min(dose.a)])
## Default range on background
miny.a <- sum(y.a2[dose.a == min(dose.a)])
minn.a <- sum(n.a2[dose.a == min(dose.a)])
a.min <- ifelse(miny.a != 0,
max(c(prop.test(miny.a, minn.a)$conf.int[1]/2, 1/(10*minn.a))),
.Machine$double.xmin)
a.max <- min(c(3*prop.test(miny.a[1], minn.a[1])$conf.int[2]/2, 1 - 1/(10*minn.a)))
a.mode <- max(c(miny.a/minn.a, 1/(5*minn.a)))
a.min
a.max
a.mode
## If info on background is given (STILL HAS TO BE IMPLEMENTED FOR COVARIATE EFFECT)
if(!is.null(bkg)){
# is_informative_a = 1
if(!is.na(bkg[2])){
a.mode = bkg[2]
}
if(!is.na(bkg[1])){
a.min = bkg[1]
}
if(!is.na(bkg[3])){
a.max = bkg[3]
}
is_informative_a = 1
}else {
message("Default prior choices used on background")
}
# Prior on a
a.vec = c(a.min, a.mode, a.max)
shape.a = shape.a
a.vec
nlevels_a <- ifelse(covariate == 'background' | covariate == 'all', nlevels, 1)
if(covariate == 'BMD_d' | covariate == 'all'){
bmd.sv <- numeric(nlevels)
for(i in 1:nlevels){
datf = data.frame(yy = y.a[covar == covar_lvls[i]], n.a = n.a[covar == covar_lvls[i]], xx = dose.a[covar == covar_lvls[i]])
if(cluster == FALSE) {
fpfit = gamlss(cbind(yy, n.a-yy)~fp(xx),family=BI(mu.link = 'logit'),data=datf)
}
# else if(cluster == TRUE) {
#   fpfit = gamlss(cbind(yy, n.a-yy)~fp(xx),family=BB,
#                  sigma.formula = ~1,data=datf)
#   fpfit2 <- try(gamlss(cbind(yy,n.a-yy)~as.factor(xx), sigma.formula=~1, family=BB, data=datf),
#          silent = TRUE)
#   rhohat <- exp(fpfit2$sigma.coefficients)/(exp(fpfit2$sigma.coefficients)+1)
#
# } else stop('provide cluster to be TRUE or FALSE')
RISK = function(x) (predict(fpfit,newdata=data.frame(xx=c(exp(x))), data=datf, type = "response")-
predict(fpfit,newdata=data.frame(xx=c(0.00000000000001)), data=datf, type = "response"))/
(1 - (predict(fpfit,newdata=data.frame(xx=c(0.00000000000001)), data=datf, type = "response")))-q
bmd.svh = try(uniroot(RISK, interval=c(-5, 0))$root,silent=TRUE)
bmd.sv[i] <- ifelse((mode(bmd.svh)=="numeric"),(exp(bmd.svh)+0.5)/2,0.05) ## why (exp(bmd.svh)+0.5)/2 ?
}
## Default prior BMD
BMD.min <- rep(.Machine$double.xmin, nlevels)
if(extended == FALSE){
BMD.max <- rep(1, nlevels)
}else{
BMD.max <- rep(maxDose, nlevels)
if(maxDose <= 1){
BMD.max <- rep(maxDose*1000, nlevels)
}
}
BMD.mode <- rep(0.5, nlevels)
## If info on BMD is given (STILL HAS TO BE ADAPTED TO COVARIATE EFFECT)
if(!is.null(prior.BMD)){
if(!is.na(prior.BMD[2])){
BMD.mode = prior.BMD[2]/maxDose
}
if(!is.na(prior.BMD[1])){
BMD.min = prior.BMD[1]/maxDose
}
if(!is.na(prior.BMD[3])){
BMD.max = prior.BMD[3]/maxDose
}
is_informative_BMD = 1
}else {
message("Default prior choices used on BMD")
}
BMD.vec <- matrix(c(BMD.min, BMD.mode, BMD.max), nrow = nlevels, ncol = 3)
shape.BMD <- rep(shape.BMD, nlevels)
}else{
datf = data.frame(yy = y.a, n.a = n.a, xx = dose.a)
if(cluster == FALSE) {
fpfit = gamlss(cbind(yy, n.a-yy)~fp(xx),family=BI(mu.link = 'logit'),data=datf)
}
# else if(cluster == TRUE) {
#   fpfit = gamlss(cbind(yy, n.a-yy)~fp(xx),family=BB,
#                  sigma.formula = ~1,data=datf)
#   fpfit2 <- try(gamlss(cbind(yy,n.a-yy)~as.factor(xx), sigma.formula=~1, family=BB, data=datf),
#          silent = TRUE)
#   rhohat <- exp(fpfit2$sigma.coefficients)/(exp(fpfit2$sigma.coefficients)+1)
#
# } else stop('provide cluster to be TRUE or FALSE')
RISK = function(x) (predict(fpfit,newdata=data.frame(xx=c(exp(x))), data=datf, type = "response")-
predict(fpfit,newdata=data.frame(xx=c(0.00000000000001)), data=datf, type = "response"))/
(1 - (predict(fpfit,newdata=data.frame(xx=c(0.00000000000001)), data=datf, type = "response")))-q
bmd.svh = try(uniroot(RISK, interval=c(-5, 0))$root,silent=TRUE)
bmd.sv <- ifelse((mode(bmd.svh)=="numeric"),(exp(bmd.svh)+0.5)/2,0.05) ## why (exp(bmd.svh)+0.5)/2 ?
## Default prior BMD
BMD.min <- .Machine$double.xmin
if(extended == FALSE){
BMD.max <- 1
}else{
BMD.max <- maxDose
if(maxDose <= 1){
BMD.max <- maxDose*1000
}
}
BMD.mode <- 0.5
## If info on BMD is given
if(!is.null(prior.BMD)){
if(!is.na(prior.BMD[2])){
BMD.mode = prior.BMD[2]/maxDose
}
if(!is.na(prior.BMD[1])){
BMD.min = prior.BMD[1]/maxDose
}
if(!is.na(prior.BMD[3])){
BMD.max = prior.BMD[3]/maxDose
}
is_informative_BMD = 1
}else {
message("Default prior choices used on BMD")
}
BMD.vec <- c(BMD.min, BMD.mode, BMD.max)
shape.BMD <- shape.BMD
}
nlevels_BMD <- ifelse(covariate == 'BMD_d' | covariate == 'all', nlevels, 1)
dim(bmd.sv) <- nlevels_BMD
### Parameter d
if(covariate == 'BMD_d' | covariate == 'all'){
# Default (normal) priors on k, d, Pert on a
# prvar.d=1; prmean.d=1;
# prmean.dQE4=0
if(prior.d == 'N11'){
prvar.d = rep(1, nlevels); prmean.d = rep(1, nlevels); truncd = 5
}else if(prior.d == 'EPA'){
# prvar.d = 0.5^2; prmean.d = 0.4; truncd = 10000
prvar.d = rep(0.5, nlevels); prmean.d = rep(0.4, nlevels); truncd = 10000
# prvar.d = 1; prmean.d = 1; truncd = 10000
}else if(prior.d == 'N05'){
prvar.d = rep(0.25, nlevels); prmean.d = rep(0.5, nlevels); truncd = 10000
}
# prvar.d=sqrt(0.5); prmean.d = prmean.d
prmean.dQE4 = rep(0, nlevels); prvar.dQE4 = rep(1, nlevels); truncdQ = 10000
}else{
# Default (normal) priors on k, d, Pert on a
# prvar.d=1; prmean.d=1;
# prmean.dQE4=0
if(prior.d == 'N11'){
prvar.d = 1; prmean.d = 1; truncd = 5
}else if(prior.d == 'EPA'){
# prvar.d = 0.5^2; prmean.d = 0.4; truncd = 10000
prvar.d = 0.5; prmean.d = 0.4; truncd = 10000
# prvar.d = 1; prmean.d = 1; truncd = 10000
}else if(prior.d == 'N05'){
prvar.d = 0.25; prmean.d = 0.5; truncd = 10000
}
# prvar.d=sqrt(0.5); prmean.d = prmean.d
prmean.dQE4 = 0; prvar.dQE4 = 1; truncdQ = 10000
}
data = summ.data
source('R/fun_Data.R')
data_all <- PREP_DATA_Q_COV(
data = data,
sumstats = sumstats,
q = q,
prior.d = prior.d,
covariate = 'all'
)
data_bkg <- PREP_DATA_Q_COV(
data = data,
sumstats = sumstats,
q = q,
prior.d = prior.d,
covariate = 'background'
)
data_dBMD <- PREP_DATA_Q_COV(
data = data,
sumstats = sumstats,
q = q,
prior.d = prior.d,
covariate = 'BMD_d'
)
data_noCOV <- PREP_DATA_QA(
data = data,
sumstats = sumstats,
q = q,
prior.d = prior.d
)
best.sub.which <- c()
data_all$data$priormu
data_bkg$data$priormu
data_dBMD$data$priormu
data_noCOV$data$priormu
library('rstantools')
library('usethis')
library('roxygen2')
# library(dplyr)
# ?rstan_create_package
# rstan_create_package('C:\\Users\\lucp9385\\Documents\\GitHub\\BMABMDR',
# roxygen=T, travis=T, license=T, auto_config=T)
# Set working directory to the new package directory
setwd('C:\\Users\\lucp9385\\Documents\\GitHub\\BMABMDR')
list.files(all.files=T)
# file.show('DESCRIPTION')
# file.show('Read-and-delete-me')
# file.remove('Read-and-delete-me')
## Save all Stan files in the 'inst/stan' subdirectory
# when installing the package these will be saved in the list 'stanmodels' that is used by R to function the package
## All functions to be used by R should be saved in the 'R/' directory
Sys.getenv("BINPREF") # should be "C:/Rtools/mingw64/bin/"
# Sys.setenv(BINPREF = "C:/rtools40/mingw64/bin/;C:/rtools40/mingw32/bin/")
Sys.setenv(BINPREF = "C:/rtools40/mingw64/bin/")
# Sys.setenv(BINPREF = "C:/rtools40/mingw$(WIN)/bin/")
Sys.getenv("PATH")
old_path <- Sys.getenv("PATH")
# new_path <- paste("C:\\Rtools\\usr\\bin", old_path, sep=";")
new_path <- paste(old_path, "C:\\rtools40\\mingw32\\bin;C:\\rtools40\\mingw64\\bin", sep=";")
# # new_path
Sys.setenv(PATH = new_path)
####################################################################################
####################################################################################
### Instructions for publishing a package on CRAN: https://r-pkgs.org/release.html
# https://cran.r-project.org/web/packages/rstantools/vignettes/minimal-rstan-package.html
## Compile package and generate the documentation
rstan_config() # recompile stan models
example(source)
try(roxygen2::roxygenize(load_code = sourceDir), silent = TRUE)
# roxygen2::roxygenize(load_code = sourceDir) # generate documentation
pkgbuild::compile_dll()
roxygen2::roxygenize()
library(BMABMDR)
library(gamlss)
data <- read.csv('~/BBMD/FINAL CODE/RatStudy.csv', header = T)
data
summ.data <- data.frame(x = data$Dose,
y = data$MeanBW,
s = data$SdBW,
n = data$N,
cov = data$Sex)
summ.data
summ.data = summ.data[summ.data$x!=0,]
q = 0.05
prior.weights = c(rep(1,4), rep(0,4), rep(1,4), rep(0,4))
FLBMD <- full.laplace_MA_Cov(summ.data,
sumstats = T,
sd = T, # option not used for Quantal data
q = q,
prior.d = 'N11',
extended = T,
ndraws = 30000,
seed = 123,
pvec = c(0.05, 0.5, 0.95),
prior.weights = prior.weights)
data <- read.csv('~/BBMD/FINAL CODE/RatStudy.csv', header = T)
data
data = data[data$Sex=='Male',]
summ.data <- data.frame(x = data$Dose,
y = data$MeanBW,
s = data$SdBW,
n = data$N)
summ.data <- data.frame(x = data$Dose,
y = data$HepatocyteHypertrophy,
n = data$N,
cov = data$Sex)
summ.data = summ.data[summ.data$x != 0,]
summ.data
data <- read.csv('~/BBMD/FINAL CODE/RatStudy.csv', header = T)
data
summ.data <- data.frame(x = data$Dose,
y = data$HepatocyteHypertrophy,
n = data$N,
cov = data$Sex)
summ.data = summ.data[summ.data$x != 0,]
summ.data
q = 0.1
prior.weights = rep(1,8)
FLBMD <- full.laplace_MA_Q_Cov(summ.data,
sumstats = T,
q = q,
prior.d = 'N11',
extended = T,
ndraws = 30000,
seed = 123,
pvec = c(0.05, 0.5, 0.95),
prior.weights = prior.weights)
FLBMD$MA
FLBMD$summary
basic.plotQ(FLBMD, 'E4_Q')
basic.plotQ(FLBMD, 'G4_Q')
FLBMD$data$x
data <- read.csv('~/BBMD/FINAL CODE/example_continuous.csv', header = T)
dim(data); data
data_N <- PREP_DATA_N(data, q = 0.05)#, geom.stats = T)
data_LN <- PREP_DATA_LN(data, q = 0.05)#, geom.stats = T)
FLBMD <- full.laplace_MA(data_N, data_LN, seed = 123, prior.weights = c(rep(1,4),rep(0,4),rep(1,4),rep(0,4)))
FLBMD$MA
FLBMD$p.msg
plot_prior(FLBMD, data_N$data, 'E4_N')
data
mod.obj = FLBMD
model_name = 'E4_N'
library('rstantools')
library('usethis')
library('roxygen2')
# library(dplyr)
# ?rstan_create_package
# rstan_create_package('C:\\Users\\lucp9385\\Documents\\GitHub\\BMABMDR',
# roxygen=T, travis=T, license=T, auto_config=T)
# Set working directory to the new package directory
setwd('C:\\Users\\lucp9385\\Documents\\GitHub\\BMABMDR')
list.files(all.files=T)
# file.show('DESCRIPTION')
# file.show('Read-and-delete-me')
# file.remove('Read-and-delete-me')
## Save all Stan files in the 'inst/stan' subdirectory
# when installing the package these will be saved in the list 'stanmodels' that is used by R to function the package
## All functions to be used by R should be saved in the 'R/' directory
Sys.getenv("BINPREF") # should be "C:/Rtools/mingw64/bin/"
# Sys.setenv(BINPREF = "C:/rtools40/mingw64/bin/;C:/rtools40/mingw32/bin/")
Sys.setenv(BINPREF = "C:/rtools40/mingw64/bin/")
# Sys.setenv(BINPREF = "C:/rtools40/mingw$(WIN)/bin/")
Sys.getenv("PATH")
old_path <- Sys.getenv("PATH")
# new_path <- paste("C:\\Rtools\\usr\\bin", old_path, sep=";")
new_path <- paste(old_path, "C:\\rtools40\\mingw32\\bin;C:\\rtools40\\mingw64\\bin", sep=";")
# # new_path
Sys.setenv(PATH = new_path)
####################################################################################
####################################################################################
### Instructions for publishing a package on CRAN: https://r-pkgs.org/release.html
# https://cran.r-project.org/web/packages/rstantools/vignettes/minimal-rstan-package.html
## Compile package and generate the documentation
rstan_config() # recompile stan models
example(source)
try(roxygen2::roxygenize(load_code = sourceDir), silent = TRUE)
# roxygen2::roxygenize(load_code = sourceDir) # generate documentation
pkgbuild::compile_dll()
roxygen2::roxygenize()
# rhub::check() # to run R CMD check for different OS
# devtools::build(binary = TRUE) # build binary package for CRAN
devtools::build() # build source package
