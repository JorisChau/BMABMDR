is_increasing = 0; is_decreasing = 0
if(obs.min < obs.max){ # increasing
is_increasing = 1
L = 1+q+0.01
# L = 1.01
U = 0
data_type = 1
pars3d = numeric()
pars3i = priormu1a[3] - L
dim(pars3d)=0
dim(pars3i)=1
}else if(obs.min > obs.max){ # decreasing
is_decreasing = 1
L = 0.01
U = 1-q-0.01
# U = 0.95
data_type = 3
pars3d = priormu1a[3] / U
pars3i = numeric()
dim(pars3d)=1
dim(pars3i)=0
}
priorSM = list(
priormu = c(mean.a[1],
diff(mean.a),
-2*log(1.5*sd(y[y!=0])),
0.5),
priorSigma = diag(c(1, rep(1, length(dose.a)-1), 1)),
priorlb = 0.001,
priorub = c(2*mean.a[1],
max(abs(diff(mean.a)))*10)
)
svSM = list(par = c(mean.a[1],
diff(mean.a),
log(1/var(y[y!=0])),
0.5))
data.modstanSM = list(N=N, n=n, nc=nc, maxN=maxN, maxNc=maxNc,
nij=nij, y=y, q=q, shift=0,
priormu=priorSM$priormu, priorSigma=priorSM$priorSigma,
priorlb=priorSM$priorlb, priorub=priorSM$priorub,
priorg=4, data_type=data_type
)
optSM = rstan::optimizing(stanmodels$mSMc, data = data.modstanSM,
seed=as.integer(123), draws = 30000,
init = svSM, hessian=TRUE)
load("~/BBMD/FINAL CODE/WS_STAN_CONT_CLUST.RData")
optSM = rstan::optimizing(mSMc, data = data.modstanSM,
seed=as.integer(123), draws = 30000,
init = svSM, hessian=TRUE)
means.SM = apply(optSM$theta_tilde[, paste0('mu[', 1:N, ']')], 2, median)
means.all$pred = means.SM
indiv.data$res = NA
for(i in 1:dim(indiv.data)[1]){
indiv.data$res[i] <- indiv.data$response[i] - (means.all$pred[which(means.all$dose == indiv.data$dose[i])])
}
# homoscedasticity
b.test.N <- bartlett.test(indiv.data$res, indiv.data$dose)
# b.test.N <- bartlett(sd.a, n.a)
if(b.test.N$p.value>=0.05){
test.var = paste0('Distributional assumption of constant variance for the normal distribution is met, Bartlett test p-value is ', round(b.test.N$p.value, 4))
message(test.var)
}else if(b.test.N$p.value<0.05){
test.var = paste0('Distributional assumption of constant variance for the normal distribution is not met, Bartlett test p-value is ', round(b.test.N$p.value, 4))
warning(test.var)
}
# normality
norm.test.N <- shapiro.test(indiv.data$res)
# b.test.N <- bartlett(sd.a, n.a)
if(norm.test.N$p.value>=0.05){
test.varN = paste0('Distributional assumption of normality of residuals for the normal distribution is met, Shapiro test p-value is ',
round(norm.test.N$p.value, 4))
message(test.varN)
}else if(norm.test.N$p.value<0.05){
test.varN = paste0('Distributional assumption of normality of residuals for the normal distribution is not met, Shapiro test p-value is ',
round(norm.test.N$p.value, 4))
warning(test.varN)
}
## Data in correct format
ret.list <- list(data = list(N=N,
n=n,
x=doses/maxDose,
# m=mean.a,
nc=nc,
maxN=maxN,
maxNc=maxNc,
nij=nij,
y=y,
shift=0,
data = indiv.data,
# s2=sd.a^2,
maxD=maxDose,q=q,priormu=priormu1a,priormuQ = priormu1bQ,
shape1 = c(fun.alpha(a = priorlb1a[1], b = priormu1a[1], c = priorub1a[1], g = shape.a),
fun.alpha(a = priorlb1a[2], b = priormu1a[2], c = priorub1a[2], g = shape.BMD),
fun.alpha(a = priorlb1a[3], b = priormu1a[3], c = priorub1a[3], g = shape.c), 0, 0,
fun.alpha(a = priorlb1a[6], b = priormu1a[6], c = priorub1a[6], g = 0.0001)),
shape2 = c(fun.beta(a = priorlb1a[1], b = priormu1a[1], c = priorub1a[1], g = shape.a),
fun.beta(a = priorlb1a[2], b = priormu1a[2], c = priorub1a[2], g = shape.BMD),
fun.beta(a = priorlb1a[3], b = priormu1a[3], c = priorub1a[3], g = shape.c), 0, 0,
fun.beta(a = priorlb1a[6], b = priormu1a[6], c = priorub1a[6], g = 0.0001)),
priorlb = priorlb1a, priorub = priorub1a, shape.a = shape.a, shape.c = shape.c, shape.BMD = shape.BMD,
priorSigma=priorSigma1a, priorSigmaQ=priorSigma1bQ, init_b = 1, data_type = data_type, L = L, U = U, is_increasing = is_increasing,
is_decreasing = is_decreasing, truncd = truncd, truncdQ = truncdQ,
is_informative_a = is_informative_a, is_informative_c = is_informative_c,
is_informative_BMD = is_informative_BMD),
# start values
start=list(par1=priormu1a[1],par2=bmd.sv,pars3i=pars3i,pars3d=pars3d,par4=prmean.d,par5=log(1/var(y[y!=0])),
par6=0.5),
startQ=list(par1=priormu1a[1],par2=bmd.sv,pars3i=pars3i,pars3d=pars3d,par4=prmean.dQE4,par5=log(1/var(y[y!=0])),
par6=0.5),
# test.var = test.var,
# test.NLN = testNLN
shapiro.p = norm.test.N$p.value,
bartlett.p = b.test.N$p.value,
shapiro.msg = test.varN,
bartlett.msg = test.var
)
?debug
debug(PREP_DATA_N_C)
data_N <- PREP_DATA_N_C(data.input, q, prior.d = 'N11')
maxy = NULL
flatC(dose.a, mean.a, inc=T)
flatC(dose.a, mean.a,inc=T) == F & is.null(maxy)
flatC(dose.a, mean.a,inc=T)
dose.a
mean.a
?flatC
?undebug
undebug(PREP_DATA_N_C)
data_N <- PREP_DATA_N_C(data.input, q, prior.d = 'N11')
source('~/BBMD/FINAL CODE/FUNs.R')
data_N <- PREP_DATA_N_C(data.input, q, prior.d = 'N11')
flatC
data.frame(dose.a, mean.a)
mean
data.frame(dose.a, mean)
sd.a
data.frame(dose.a, sd.a)
unique(indiv.data$dose)
data_N <- PREP_DATA_N_C(data.input, q, prior.d = 'N11')
traceback()
data.frame(dose.a, c())
means.all
mean.a
data <- data.input
library(dplyr)
indiv.data <- data.frame(dose = data[,1],
response = data[,2],
litter = data[,3])
indiv.data <- indiv.data %>%
dplyr::group_by(dose, litter) %>%
dplyr::arrange(by_group = dose) # order dose groups
indiv.data <- indiv.data %>%
dplyr::mutate(cluster = dplyr::cur_group_id(),
count = n())
dose.a = indiv.data$dose
maxDose = max(dose.a)
doses = unique(dose.a)
N = length(unique(dose.a)) # dose groups
n = c() # number of litters per dose group (vector of size N)
for(i in 1:N){
cnt = plyr::count(indiv.data$litter[indiv.data$dose==doses[i]])
n[i] = length(unique(cnt$x))
}
nc = length(unique(indiv.data$cluster)) # number of unique dose x litter combinations (i.e. clusters)
cid = unique(indiv.data$cluster) # cluster ids
maxN = max(indiv.data$count) # max number of obs per cluster
maxNc = max(n) # max number of litters per dose group
# nij = as.matrix(table(indiv.data$dose, indiv.data$litter))
nij = matrix(0, nrow = N, ncol = maxNc)
for(i in 1:N){
cnt = plyr::count(indiv.data$litter[indiv.data$dose==doses[i]])
obs = cnt$freq
if(length(obs) < maxNc){
obs = c(obs, rep(0, maxNc-length(obs)))
}
nij[i, ] = obs
}
y = matrix(0, nrow = nc, ncol = maxN)
for(i in 1:nc){
obs = indiv.data$response[indiv.data$cluster==cid[i]]
if(length(obs) < maxN){
obs = c(obs, rep(0, maxN-length(obs)))
}
y[i, ] = obs
}
datind <- data.frame(x = indiv.data$dose,
y = indiv.data$response)
obs.min = mean(indiv.data$response[indiv.data$dose==0])
obs.max = mean(indiv.data$response[indiv.data$dose==maxDose])
## Overall mean for test of flatness
means.all <- indiv.data %>%
group_by(dose) %>%
summarise(mresp = mean(response))
dose.a = unique(indiv.data$dose)
mean.a = c()
for(m in 1:length(dose.a)){
mean.a[m] <- means.all$mresp[means.all$dose == dose.a[m]]
}
min.min = 0.5*obs.min
mode.min = obs.min
max.min = 2*obs.min
min.max = 0.5*obs.max
max.max = obs.min*(1-q-0.01)
# max.max = obs.min
mode.max = obs.max
dose.a; mean.a
flatC(dose.a, mean.a, inc = F)
if(obs.min < obs.max){
# for a
min.min = 0.001
mode.min = obs.min
max.min = 2*obs.min
# for c
min.max = obs.min*(1.01+q)
max.max = 2*obs.max
mode.max = obs.max
if(flatC(dose.a, mean.a, inc=T) == F & is.null(maxy)){
mode.max = 3*obs.max
min.max  = obs.min*(1.01+q)
max.max = 2*mode.max
warning(
"The data do not contain information on the asymptote, and the default prior for fold change has been based on 3 times the observed maximum.
Please provide prior input on the maximum response by specifying 'maxy', if available."
)
}
## Check appropriateness of BMR value
if(obs.min*(1+q) > obs.max){
warning('The data do not contain values corresponding to the chosen BMR, lowering the specified value of q may be necessary.')
}
}else if(obs.min > obs.max){
min.min = 0.5*obs.min
mode.min = obs.min
max.min = 2*obs.min
min.max = 0.5*obs.max
max.max = obs.min*(1-q-0.01)
# max.max = obs.min
mode.max = obs.max
if(flatC(dose.a, mean.a, inc=F) == F & is.null(maxy)){
mode.max = 0.5*obs.max
min.max  = 0.1*obs.max
max.max = obs.min*(1-q-0.01)
# max.max = obs.min
warning(
"The data do not contain information on the asymptote, and the default prior for fold change has been based on half the observed maximum.
Please provide prior input on the maximum response by specifying 'maxy', if available."
)
}
## Check appropriateness of BMR value
if(obs.min*(1-q) < obs.max){
warning('The data do not contain values corresponding to the chosen BMR, lowering the specified value of q may be necessary.')
}
}
obs.min
obs.max
flatC(dose.a, mean.a, inc=T) == F & is.null(maxy)
flatC(dose.a, mean.a, inc=T)
means.all
unique(indiv.data$dose)
1:length(dose.a)
means.all$mresp[means.all$dose == dose.a[m]]
m
load('~/BBMD/FINAL CODE/TESTING/das5.rda')
data.input <- das5$data
data.input <- data.frame(dose = data.input$dose,
response = data.input$foetalweight,
litter = data.input$number)
data_N <- PREP_DATA_N_C(data.input, q = 0.1, prior.d = 'N11')
data_LN <- PREP_DATA_LN_C(data.input, q = 0.1, prior.d = 'N11')
data = data.input
## cluster (ij) = combination of dose (i) and litter (j)
library(dplyr)
indiv.data <- data.frame(dose = data[,1],
response = data[,2],
litter = data[,3])
indiv.data <- indiv.data %>%
dplyr::group_by(dose, litter) %>%
dplyr::arrange(by_group = dose) # order dose groups
indiv.data <- indiv.data %>%
dplyr::mutate(cluster = dplyr::cur_group_id(),
count = n())
dose.a = indiv.data$dose
maxDose = max(dose.a)
doses = unique(dose.a)
N = length(unique(dose.a)) # dose groups
n = c() # number of litters per dose group (vector of size N)
for(i in 1:N){
cnt = plyr::count(indiv.data$litter[indiv.data$dose==doses[i]])
n[i] = length(unique(cnt$x))
}
nc = length(unique(indiv.data$cluster)) # number of unique dose x litter combinations (i.e. clusters)
cid = unique(indiv.data$cluster) # cluster ids
maxN = max(indiv.data$count) # max number of obs per cluster
maxNc = max(n) # max number of litters per dose group
# nij = as.matrix(table(indiv.data$dose, indiv.data$litter))
nij = matrix(0, nrow = N, ncol = maxNc)
for(i in 1:N){
cnt = plyr::count(indiv.data$litter[indiv.data$dose==doses[i]])
obs = cnt$freq
if(length(obs) < maxNc){
obs = c(obs, rep(0, maxNc-length(obs)))
}
nij[i, ] = obs
}
y = matrix(0, nrow = nc, ncol = maxN)
for(i in 1:nc){
obs = indiv.data$response[indiv.data$cluster==cid[i]]
if(length(obs) < maxN){
obs = c(obs, rep(0, maxN-length(obs)))
}
y[i, ] = obs
}
datind <- data.frame(x = indiv.data$dose,
y = indiv.data$response)
obs.min = mean(indiv.data$response[indiv.data$dose==0])
obs.max = mean(indiv.data$response[indiv.data$dose==maxDose])
is_informative_BMD = 0
is_informative_a = 0
is_informative_c = 0
## Overall mean for test of flatness
means.all <- indiv.data %>%
group_by(dose) %>%
summarise(mresp = mean(response))
dose.a = unique(indiv.data$dose)
mean.a = c()
for(m in 1:length(dose.a)){
mean.a[m] <- means.all$mresp[means.all$dose == dose.a[m]]
}
dose.a
mean.a
if(obs.min < obs.max){
# for a
min.min = 0.001
mode.min = obs.min
max.min = 2*obs.min
# for c
min.max = obs.min*(1.01+q)
max.max = 2*obs.max
mode.max = obs.max
if(flatC(dose.a, mean.a, inc=T) == F & is.null(maxy)){
mode.max = 3*obs.max
min.max  = obs.min*(1.01+q)
max.max = 2*mode.max
warning(
"The data do not contain information on the asymptote, and the default prior for fold change has been based on 3 times the observed maximum.
Please provide prior input on the maximum response by specifying 'maxy', if available."
)
}
## Check appropriateness of BMR value
if(obs.min*(1+q) > obs.max){
warning('The data do not contain values corresponding to the chosen BMR, lowering the specified value of q may be necessary.')
}
}else if(obs.min > obs.max){
min.min = 0.5*obs.min
mode.min = obs.min
max.min = 2*obs.min
min.max = 0.5*obs.max
max.max = obs.min*(1-q-0.01)
# max.max = obs.min
mode.max = obs.max
if(flatC(dose.a, mean.a, inc=F) == F & is.null(maxy)){
mode.max = 0.5*obs.max
min.max  = 0.1*obs.max
max.max = obs.min*(1-q-0.01)
# max.max = obs.min
warning(
"The data do not contain information on the asymptote, and the default prior for fold change has been based on half the observed maximum.
Please provide prior input on the maximum response by specifying 'maxy', if available."
)
}
## Check appropriateness of BMR value
if(obs.min*(1-q) < obs.max){
warning('The data do not contain values corresponding to the chosen BMR, lowering the specified value of q may be necessary.')
}
}
flatC(dose.a, mean.a, inc=F)
#' Function for internal use
#'
#' @param dose value
#' @param mean value
#' @param inc logical variable to indicate if the dose-resonse curve is increasing or decreasing
#' @return .logical value indicating if the dose-response curve is flat or not
#'
#' @export flatC
#'
flatC = function(dose,mean,inc){ # To determine if DR curve flattens or not
flat=F
if(inc==TRUE){
# dat = data.frame(dose,mean)
datf=data.frame(yy=mean,xx=dose+0.0001)
fpfit=gamlss::gamlss(yy~fp(xx),family=NO,data=datf)
# maxdiff=max(abs(diff(predict(fpfit),lag=1,differences=1))/diff(log(dose+0.0001),lag=1,differences=1))
# lastdiff=(abs(diff(predict(fpfit),lag=1,differences=1))/diff(log(dose+0.0001),lag=1,differences=1))[length(dose)-1]
maxdiff=max((diff(predict(fpfit),lag=1,differences=1))/diff(log(dose+0.0001),lag=1,differences=1))
lastdiff=((diff(predict(fpfit),lag=1,differences=1))/diff(log(dose+0.0001),lag=1,differences=1))[length(dose)-1]
if (lastdiff/maxdiff<(0.5)) flat=T # flat if last incremental change smaller than 50% of the maximal change
return(flat)
}else if(inc==FALSE){
# dat = data.frame(dose,mean)
datf=data.frame(yy=mean,xx=dose+0.0001)
fpfit=gamlss::gamlss(yy~fp(xx),family=NO,data=datf)
# maxdiff=max(abs(diff(predict(fpfit),lag=1,differences=1))/diff(log(dose+0.0001),lag=1,differences=1))
# lastdiff=(abs(diff(predict(fpfit),lag=1,differences=1))/diff(log(dose+0.0001),lag=1,differences=1))[length(dose)-1]
maxdiff=max(abs(diff(predict(fpfit),lag=1,differences=1))/diff(log(dose+0.0001),lag=1,differences=1))
lastdiff=(abs(diff(predict(fpfit),lag=1,differences=1))/diff(log(dose+0.0001),lag=1,differences=1))[length(dose)-1]
if (lastdiff/maxdiff<(0.5)) flat=T # flat if last incremental change smaller than 50% of the maximal change
return(flat)
}
}
flatC
flat(dose.a, mean.a)
mean.a
flat(dose.a, mean.a, inc = F)
?devtools::reload
devtools::reload()
flatC
?flatC
BMABMDR::flatC
# roxygen2::roxygenize(load_code = sourceDir) # generate documentation
pkgbuild::compile_dll()
roxygen2::roxygenize()
BMABMDR::flatC
data_N <- PREP_DATA_N_C(data.input, q, prior.d = 'N11')
data_N <- BMABMDR::PREP_DATA_N_C(data.input, q, prior.d = 'N11')
dose
mean
# roxygen2::roxygenize(load_code = sourceDir) # generate documentation
pkgbuild::compile_dll()
roxygen2::roxygenize()
BMABMDR::flatC
flatC(dose.a, mean.a, inc = F)
BMABMDR::flatC(dose.a, mean.a, inc=FALSE)
data_N <- PREP_DATA_N_C(data.input, q, prior.d = 'N11')
dose.a
mean.a
length(dose.a)
length(mean.a)
# dat = data.frame(dose,mean)
datf=data.frame(yy=mean.a,xx=dose.a+0.0001)
datf
gamlss::gamlss(mean.a~fp(dose.a+0.0001), family=NO)
fpfit=gamlss::gamlss(mean.a~fp(dose.a+0.0001), family=NO)
# maxdiff=max(abs(diff(predict(fpfit),lag=1,differences=1))/diff(log(dose+0.0001),lag=1,differences=1))
# lastdiff=(abs(diff(predict(fpfit),lag=1,differences=1))/diff(log(dose+0.0001),lag=1,differences=1))[length(dose)-1]
maxdiff=max((diff(predict(fpfit),lag=1,differences=1))/diff(log(dose.a+0.0001),lag=1,differences=1))
lastdiff=((diff(predict(fpfit),lag=1,differences=1))/diff(log(dose.a+0.0001),lag=1,differences=1))[length(dose.a)-1]
lastdiff/maxdiff<(0.5)
#' Function for internal use
#'
#' @param dose value
#' @param mean value
#' @param inc logical variable to indicate if the dose-resonse curve is increasing or decreasing
#' @return .logical value indicating if the dose-response curve is flat or not
#'
#' @export flatC
#'
flatC = function(dose.a,mean.a,inc){ # To determine if DR curve flattens or not
flat=F
if(inc==TRUE){
# dat = data.frame(dose,mean)
# datf=data.frame(yy=mean.a,xx=dose.a+0.0001)
# fpfit=gamlss::gamlss(yy~fp(xx),family=NO,data=datf)
fpfit=gamlss::gamlss(mean.a~fp(dose.a+0.0001),family=NO)
# maxdiff=max(abs(diff(predict(fpfit),lag=1,differences=1))/diff(log(dose+0.0001),lag=1,differences=1))
# lastdiff=(abs(diff(predict(fpfit),lag=1,differences=1))/diff(log(dose+0.0001),lag=1,differences=1))[length(dose)-1]
maxdiff=max((diff(predict(fpfit),lag=1,differences=1))/diff(log(dose.a+0.0001),lag=1,differences=1))
lastdiff=((diff(predict(fpfit),lag=1,differences=1))/diff(log(dose.a+0.0001),lag=1,differences=1))[length(dose.a)-1]
if (lastdiff/maxdiff<(0.5)) flat=T # flat if last incremental change smaller than 50% of the maximal change
return(flat)
}else if(inc==FALSE){
# dat = data.frame(dose,mean)
# datf=data.frame(yy=mean.a,xx=dose.a+0.0001)
# fpfit=gamlss::gamlss(yy~fp(xx),family=NO,data=datf)
fpfit=gamlss::gamlss(mean.a~fp(dose.a+0.0001),family=NO)
# maxdiff=max(abs(diff(predict(fpfit),lag=1,differences=1))/diff(log(dose+0.0001),lag=1,differences=1))
# lastdiff=(abs(diff(predict(fpfit),lag=1,differences=1))/diff(log(dose+0.0001),lag=1,differences=1))[length(dose)-1]
maxdiff=max(abs(diff(predict(fpfit),lag=1,differences=1))/diff(log(dose.a+0.0001),lag=1,differences=1))
lastdiff=(abs(diff(predict(fpfit),lag=1,differences=1))/diff(log(dose.a+0.0001),lag=1,differences=1))[length(dose.a)-1]
if (lastdiff/maxdiff<(0.5)) flat=T # flat if last incremental change smaller than 50% of the maximal change
return(flat)
}
}
flatC(dose.a, mean.a, inc = F)
# roxygen2::roxygenize(load_code = sourceDir) # generate documentation
pkgbuild::compile_dll()
roxygen2::roxygenize()
data_N <- PREP_DATA_N_C(data.input, q, prior.d = 'N11')
gamlss::gamlss(mean.a ~ fp(dose.a + 1e-04), family = NO)
gamlss::gamlss(mean.a ~ fp(dose.a + 1e-04), family = NO())
dose.a
mean.a
flat(dose.a, mean.a)
flat(dose.a, mean.a, NA, inc = F)
# roxygen2::roxygenize(load_code = sourceDir) # generate documentation
pkgbuild::compile_dll()
roxygen2::roxygenize()
data_N <- PREP_DATA_N_C(data.input, q, prior.d = 'N11')
# roxygen2::roxygenize(load_code = sourceDir) # generate documentation
pkgbuild::compile_dll()
roxygen2::roxygenize()
data_N <- PREP_DATA_N_C(data.input, q, prior.d = 'N11')
# roxygen2::roxygenize(load_code = sourceDir) # generate documentation
pkgbuild::compile_dll()
roxygen2::roxygenize()
data_N <- PREP_DATA_N_C(data.input, q, prior.d = 'N11')
data_LN <- PREP_DATA_LN_C(data.input, q, prior.d = 'N11')
#### To test changes in R functions: run compile_dll() and roxygenize()
# devtools::reload()
# devtools::check()
devtools::build() # build source package
Sys.setenv(BINPREF = "C:/rtools40/mingw64/bin/;C:/rtools40/mingw32/bin/;")
Sys.setenv(PATH = "C:\\rtools40\\usr\\bin\\;")
install.packages("~/GitHub/BMABMDR_0.0.0.9023.tar.gz", repos = NULL, type = "source")
