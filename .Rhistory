w = c(w, fun.w.bin(DIHE4, llE4Q, minll, optE4_Q, data$priormu, data$priorSigma,
data$priorlb, data$priorub, data$priorgama[1], data$priorgama[2],
data$truncd))
} else {
w = c(w, fun.w.betabin(DIHE4, llE4Q, minll, optE4_Q, data$priormu, data$priorSigma,
data$priorlb, data$priorub, data$priorgama[1], data$priorgama[2],
data$truncd))
}
}else{w=c(w,0)}
if(prior.weights[2]>0){
DIHIE4h=det(-solve(optIE4_Q$hessian))
DIHIE4=ifelse(DIHIE4h<0,0,DIHIE4h)
if(data$is_bin==1) {
w = c(w, fun.w.bin(DIHIE4, llIE4Q, minll, optIE4_Q, data$priormu, data$priorSigma,
data$priorlb, data$priorub, data$priorgama[1], data$priorgama[2],
data$truncd))
} else {
w = c(w, fun.w.betabin(DIHIE4, llIE4Q, minll, optIE4_Q, data$priormu, data$priorSigma,
data$priorlb, data$priorub, data$priorgama[1], data$priorgama[2],
data$truncd))
}
}else{w=c(w,0)}
if(prior.weights[3]>0){
DIHH4h=det(-solve(optH4_Q$hessian))
DIHH4=ifelse(DIHH4h<0,0,DIHH4h)
if(data$is_bin==1) {
w = c(w, fun.w.bin(DIHH4, llH4Q, minll, optH4_Q, data$priormu, data$priorSigma,
data$priorlb, data$priorub, data$priorgama[1], data$priorgama[2],
data$truncd))
} else {
w = c(w, fun.w.betabin(DIHH4, llH4Q, minll, optH4_Q, data$priormu, data$priorSigma,
data$priorlb, data$priorub, data$priorgama[1], data$priorgama[2],
data$truncd))
}
}else{w=c(w,0)}
if(prior.weights[4]>0){
DIHLN4h=det(-solve(optLN4_Q$hessian))
DIHLN4=ifelse(DIHLN4h<0,0,DIHLN4h)
if(data$is_bin==1) {
w = c(w, fun.w.bin(DIHLN4, llLN4Q, minll, optLN4_Q, data$priormu, data$priorSigma,
data$priorlb, data$priorub, data$priorgama[1], data$priorgama[2],
data$truncd))
} else {
w = c(w, fun.w.betabin(DIHLN4, llLN4Q, minll, optLN4_Q, data$priormu, data$priorSigma,
data$priorlb, data$priorub, data$priorgama[1], data$priorgama[2],
data$truncd))
}
}else{w=c(w,0)}
if(prior.weights[5]>0){
DIHG4h=det(-solve(optG4_Q$hessian))
DIHG4=ifelse(DIHG4h<0,0,DIHG4h)
if(data$is_bin==1) {
w = c(w, fun.w.bin(DIHG4, llG4Q, minll, optG4_Q, data$priormu, data$priorSigma,
data$priorlb, data$priorub, data$priorgama[1], data$priorgama[2],
data$truncd))
} else {
w = c(w, fun.w.betabin(DIHG4, llG4Q, minll, optG4_Q, data$priormu, data$priorSigma,
data$priorlb, data$priorub, data$priorgama[1], data$priorgama[2],
data$truncd))
}
}else{w=c(w,0)}
if(prior.weights[6]>0){
DIHQE4h=det(-solve(optQE4_Q$hessian))
DIHQE4=ifelse(DIHQE4h<0,0,DIHQE4h)
if(data$is_bin==1) {
w = c(w, fun.w.bin(DIHQE4, llQE4Q, minll, optQE4_Q, data$priormuQ, data$priorSigmaQ,
data$priorlb, data$priorub, data$priorgama[1], data$priorgama[2],
data$truncdQ))
} else {
w = c(w, fun.w.betabin(DIHQE4, llQE4Q, minll, optQE4_Q, data$priormuQ, data$priorSigmaQ,
data$priorlb, data$priorub, data$priorgama[1], data$priorgama[2],
data$truncdQ))
}
}else{w=c(w,0)}
if(prior.weights[7]>0){
DIHP4h=det(-solve(optP4_Q$hessian))
DIHP4=ifelse(DIHP4h<0,0,DIHP4h)
if(data$is_bin==1) {
w = c(w, fun.w.bin(DIHP4, llP4Q, minll, optP4_Q, data$priormu, data$priorSigma,
data$priorlb, data$priorub, data$priorgama[1], data$priorgama[2],
data$truncd))
} else {
w = c(w, fun.w.betabin(DIHP4, llP4Q, minll, optP4_Q, data$priormu, data$priorSigma,
data$priorlb, data$priorub, data$priorgama[1], data$priorgama[2],
data$truncd))
}
}else{w=c(w,0)}
if(prior.weights[8]>0){
DIHL4h=det(-solve(optL4_Q$hessian))
DIHL4=ifelse(DIHL4h<0,0,DIHL4h)
if(data$is_bin==1) {
w = c(w, fun.w.bin(DIHL4, llL4Q, minll, optL4_Q, data$priormu, data$priorSigma,
data$priorlb, data$priorub, data$priorgama[1], data$priorgama[2],
data$truncd))
} else {
w = c(w, fun.w.betabin(DIHL4, llL4Q, minll, optL4_Q, data$priormu, data$priorSigma,
data$priorlb, data$priorub, data$priorgama[1], data$priorgama[2],
data$truncd))
}
}else{w=c(w,0)}
w <- ifelse(w == 'Inf' | is.na(w), 0, w)
prior.weights = prior.weights/sum(prior.weights==1) # in case this has changed for G4
lpw=(prior.weights*w)/sum(prior.weights*w)
}
# the model average posterior as a mixture
count=round(lpw*ndraws)
mabmd=(c(# normal
if(prior.weights[1]>0) sample(optE4_Q$theta_tilde[,2],count[1],replace=T),
if(prior.weights[2]>0) sample(optIE4_Q$theta_tilde[,2],count[2],replace=T),
if(prior.weights[3]>0) sample(optH4_Q$theta_tilde[,2],count[3],replace=T),
if(prior.weights[4]>0) sample(optLN4_Q$theta_tilde[,2],count[4],replace=T),
if(prior.weights[5]>0) sample(optG4_Q$theta_tilde[,2],count[5],replace=T),
if(prior.weights[6]>0) sample(optQE4_Q$theta_tilde[,2],count[6],replace=T),
if(prior.weights[7]>0) sample(optP4_Q$theta_tilde[,2],count[7],replace=T),
if(prior.weights[8]>0) sample(optL4_Q$theta_tilde[,2],count[8],replace=T)
))
maci=quantile(mabmd,pvec)*data$maxD ## original scale
names(maci)=c("BMDL","BMD","BMDU")
maci
if(TRUE %in% (mabmd > data$maxD) && data$maxD > 1){
mabmd = ifelse(mabmd > data$maxD, data$maxD, mabmd)
p.msg = 'The model averaged posterior distribution has been truncated at max(Dose)^2'
warnings('The model averaged posterior distribution has been truncated at max(Dose)^2')
}else{
p.msg = ''
}
BMDq = quantile(mabmd, seq(0,1,0.005))*data$maxD ## original scale
BMDL = c(BMDL, maci[1]/data$maxD); BMD = c(BMD, maci[2]/data$maxD);
BMDU = c(BMDU, maci[3]/data$maxD)
names(BMDL) <- c("E4_Q","IE4_Q","H4_Q","LN4_Q","G4_Q","QE4_Q","P4_Q","L4_Q","MA")
model = c("E4_Q","IE4_Q","H4_Q","LN4_Q","G4_Q","QE4_Q","P4_Q","L4_Q","MA")
model = as.factor(model)
weight = c(lpw[1], lpw[2], lpw[3], lpw[4], lpw[5], lpw[6], lpw[7], lpw[8], 1)
names(lpw) = model[1:8]
### Model-averaged response per dose level
dr.MA <- c()
for(i in 1:length(data$x)){
xx <- c(DRM_E4_Q[i],DRM_IE4_Q[i],DRM_H4_Q[i],DRM_LN4_Q[i],DRM_G4_Q[i],DRM_QE4_Q[i],
DRM_P4_Q[i], DRM_L4_Q[i])
dr.MA[i] = weighted.mean(x = xx,
w = lpw,
na.rm = T)
}
modelnames = c("E4","IE4","H4","LN4","G4","QE4","P4","L4")
if(maci[2]/maci[1] > 20){
warning('BMD/BMDL is larger than 20')
}
if(maci[3]/maci[1] > 50){
warning('BMDU/BMDL is larger than 50')
}
if(maci[2] < (data.Q$data$x[2]*data.Q$data$maxD/10)){
warning('BMD is 10 times lower than the lowest non-zero dose')
}
### best fitting model vs saturated ANOVA model
best.fit = modelnames[which(weight[1:8] == max(weight[1:8]))]
nrchains = 3; nriterations = 3000; warmup = 1000; delta = 0.8; treedepth = 10
bfTest <- modelTestQ(best.fit, data.Q, get(paste0('opt', best.fit, '_Q')), type = 'Laplace',
seed, ndraws, nrchains, nriterations, warmup, delta, treedepth)
traceback()
best.fit
paste0('opt', best.fit, '_Q')
N = data.Q$data$N
data.Q$data$is_betabin
yasum <- tapply(data.Q$data$y, data.Q$data$x, sum, na.rm = TRUE)
nasum <- tapply(data.Q$data$n, data.Q$data$x, sum, na.rm = TRUE)
yamean <- yasum/nasum
ydiff <- diff(yasum/nasum)
datf = data.frame(yy = data.Q$data$y, n.a = data.Q$data$n, xx = data.Q$data$x)
fpfit2 <- try(gamlss(cbind(yy,n.a-yy)~as.factor(xx), sigma.formula=~1, family=BB, data=datf),
silent = TRUE)
fpfit2
fpfit2 <- try(gamlss(cbind(yy,n.a-yy)~as.factor(xx), sigma.formula=~1, family=gamlss.dist::BB(), data=datf),
silent = TRUE)
fpfit2
# example(source)
# try(roxygen2::roxygenize(load_code = sourceDir), silent = TRUE)
# # roxygen2::roxygenize(load_code = sourceDir) # generate documentation
pkgbuild::compile_dll()
roxygen2::roxygenize()
testthat::test_file('tests/testthat/testClusteredQuantal.R')
dataDir <- '~/GitHub/BMABMDR/data/'
data <- read.csv(file.path(dataDir, "example_clusteredQuantal.csv"))
orderedData <- data[,
c("dose", "y", "n", "litter")
]
argListPrep <- list(
data = orderedData,
q = 0.1,
extended = TRUE,
cluster = TRUE
)
prepData <- do.call("PREP_DATA_QA", argListPrep)
# Fit models
argListFit <- list(
data.Q = prepData,
prior.weights = rep(1,8)
)
modelFit <- do.call("full.laplaceQ_MA", argListFit)
expect_s3_class(modelFit, 'BMADRQ')
pFLBMD_Q = plot.BMADRQ(modelFit, weight_type = "LP", include_data = T, all = F, title = '')
expect_type(pFLBMD_Q, 'list')
names(pFLBMD_Q)
expect_equal(names(pFLBMD_Q), c("BMDs", "weights","model_fit2", "model_fit", "MA_fit2", "MA_fit"))
dataDir <- '~/GitHub/BMABMDR/data/'
data.test <- read.csv(file.path(dataDir,'test_data.csv'), sep = ';')
summ.data <- data.frame(
x = data.test$Dose,
y = data.test$Mean,
s = data.test$SD,
n = data.test$N,
cov = data.test$group
)
q = 0.2
prior.weights = rep(1,16)
# Fit models
FLBMD <- full.laplace_MA_Cov(summ.data,
sumstats = T,
sd = T, # option not used for Quantal data
q = q,
prior.d = 'N11',
extended = F,
ndraws = 30000,
seed = 123,
pvec = c(0.05, 0.5, 0.95),
prior.weights = prior.weights)
class(FLBMD$summary)
expect_s3_class(FLBMD, 'BMADR')
expect_true(is.numeric(FLBMD$MA))
expect_true(is.data.frame(FLBMD$summary))
class(FLBMD)
expect_type(FLBMD, 'list')
# Plots
pt <- basic.plot(FLBMD, model_name = 'E4_N', increasing = T)
class(pt)
expect_true(is.ggplot(pt))
load(file.path(dataDir, "das1.rda"))
data.test <- das1$data
ind.data <- data.frame(
x = data.test$Dose,
y = data.test$LDH,
#          s = data.test$SD,
#          n = data.test$N,
cov = data.test$sex
)
ind.data <- ind.data[which(!is.na(ind.data$y)),]
load(file.path(dataDir, "das1.rda"))
data.test <- das1$data
ind.data <- data.frame(
x = data.test$Dose,
y = data.test$LDH,
#          s = data.test$SD,
#          n = data.test$N,
cov = data.test$sex
)
ind.data <- ind.data[which(!is.na(ind.data$y)),]
q = 0.05
prior.weights = rep(1,16)
# Fit models TODO: returns an error
FLBMD <- full.laplace_MA_Cov(
data = ind.data,
sumstats = FALSE,
sd = TRUE, # option not used for Quantal data
q = q,
prior.d = 'N11'
)
expect_type(FLBMD, 'list')
expect_true(is.data.frame(FLBMD$summary))
dataDir <- '~/GitHub/BMABMDR/data/'
data <- read.csv(file.path(dataDir, "example_quantal.csv"))
# Each covariate level should be present in each dose group
data.input <- data.frame(
dose = rep(data$dose, 2),
y = rep(data$response, 2),
n = rep(data$size, 2),
covariate = c(rep('Male', 5), rep('Female', 5))
)
q = 0.1
# Fit models TODO: returns an error
modelFit <- full.laplace_MA_Q_Cov(
data = data.input,
q = q
)
expect_true(is.data.frame(modelFit$summary))
# Plots
pt <- basic.plotQ(modelFit, model_name = 'E4_Q')
expect_true(is.ggplot(pt))
# Fit without covariate
data.input.Q <- PREP_DATA_QA(data = data.input, q = q, sumstats = T)
modelFit <- full.laplaceQ_MA(data.input.Q, prior.weights = rep(1,8), pvec = c(0.05,0.5,0.95))
expect_s3_class(modelFit, 'BMADRQ')
dataDir <- '~/GitHub/BMABMDR/data/'
load(file.path(file.path(dataDir, "das1.rda")))
indData <- na.omit(das1$data[, c("Dose", "LDH")]) #BW instead of LDH works
argListPrepData <- list(
data = indData,
sumstats = FALSE,
sd = TRUE,
q = 0.05,
extended = TRUE
)
data_N <- do.call("PREP_DATA_N", argListPrepData)
data_LN <-  do.call("PREP_DATA_LN", argListPrepData)
argListFit <- list(
data.N = data_N,
data.LN = data_LN,
prior.weights = rep(1,16)
)
modelFit <- do.call("full.laplace_MA", argListFit)
# modelFit <- do.call("sampling_MA", argListFit)
modelFit$w.msg
expect_s3_class(modelFit, 'BMADR')
modelPlot <- plot.BMADR(
mod.obj = modelFit,
weight_type = "LP",
type = ifelse(argListFit$data.N$data$is_increasing == 1, "increasing", "decreasing"),
title = '', all = F, log = T
)
expect_type(modelPlot, 'list')
names(pFLBMD)
names(modelPlot)
expect_equal(names(modelPlot), c("BMDs", "weights", "model_fit_N", "model_fit_LN", "model_fit", "MA_fit"))
testthat::test_file('tests/testthat/test_errorPlot.R')
library('rstantools')
library('usethis')
library('roxygen2')
# library(dplyr)
# ?rstan_create_package
# rstan_create_package('C:\\Users\\lucp9385\\Documents\\GitHub\\BMABMDR',
# roxygen=T, travis=T, license=T, auto_config=T)
# Set working directory to the new package directory
setwd('C:\\Users\\lucp9385\\Documents\\GitHub\\BMABMDR')
list.files(all.files=T)
# file.show('DESCRIPTION')
# file.show('Read-and-delete-me')
# file.remove('Read-and-delete-me')
## Save all Stan files in the 'inst/stan' subdirectory
# when installing the package these will be saved in the list 'stanmodels' that is used by R to function the package
## All functions to be used by R should be saved in the 'R/' directory
Sys.getenv("BINPREF") # should be "C:/Rtools/mingw64/bin/"
# Sys.setenv(BINPREF = "C:/rtools40/mingw64/bin/;C:/rtools40/mingw32/bin/")
Sys.setenv(BINPREF = "C:/rtools40/mingw64/bin/")
# Sys.setenv(BINPREF = "C:/rtools40/mingw$(WIN)/bin/")
Sys.getenv("PATH")
old_path <- Sys.getenv("PATH")
# new_path <- paste("C:\\Rtools\\usr\\bin", old_path, sep=";")
new_path <- paste(old_path, "C:\\rtools40\\mingw32\\bin;C:\\rtools40\\mingw64\\bin", sep=";")
# # new_path
Sys.setenv(PATH = new_path)
## Compile package and generate the documentation
rstan_config() # recompile stan models
# example(source)
# try(roxygen2::roxygenize(load_code = sourceDir), silent = TRUE)
# # roxygen2::roxygenize(load_code = sourceDir) # generate documentation
pkgbuild::compile_dll()
roxygen2::roxygenize()
#### Run test scripts
# library(testthat)
devtools::test(stop_on_failure = TRUE)
library('rstantools')
library('usethis')
library('roxygen2')
# library(dplyr)
# ?rstan_create_package
# rstan_create_package('C:\\Users\\lucp9385\\Documents\\GitHub\\BMABMDR',
# roxygen=T, travis=T, license=T, auto_config=T)
# Set working directory to the new package directory
setwd('C:\\Users\\lucp9385\\Documents\\GitHub\\BMABMDR')
list.files(all.files=T)
# file.show('DESCRIPTION')
# file.show('Read-and-delete-me')
# file.remove('Read-and-delete-me')
## Save all Stan files in the 'inst/stan' subdirectory
# when installing the package these will be saved in the list 'stanmodels' that is used by R to function the package
## All functions to be used by R should be saved in the 'R/' directory
Sys.getenv("BINPREF") # should be "C:/Rtools/mingw64/bin/"
# Sys.setenv(BINPREF = "C:/rtools40/mingw64/bin/;C:/rtools40/mingw32/bin/")
Sys.setenv(BINPREF = "C:/rtools40/mingw64/bin/")
# Sys.setenv(BINPREF = "C:/rtools40/mingw$(WIN)/bin/")
Sys.getenv("PATH")
old_path <- Sys.getenv("PATH")
# new_path <- paste("C:\\Rtools\\usr\\bin", old_path, sep=";")
new_path <- paste(old_path, "C:\\rtools40\\mingw32\\bin;C:\\rtools40\\mingw64\\bin", sep=";")
# # new_path
Sys.setenv(PATH = new_path)
####################################################################################
####################################################################################
### Instructions for publishing a package on CRAN: https://r-pkgs.org/release.html
# https://cran.r-project.org/web/packages/rstantools/vignettes/minimal-rstan-package.html
## Compile package and generate the documentation
rstan_config() # recompile stan models
# example(source)
# try(roxygen2::roxygenize(load_code = sourceDir), silent = TRUE)
# # roxygen2::roxygenize(load_code = sourceDir) # generate documentation
pkgbuild::compile_dll()
roxygen2::roxygenize()
# devtools::build_readme()
#### Run test scripts
# library(testthat)
devtools::test(stop_on_failure = TRUE)
# example(source)
# try(roxygen2::roxygenize(load_code = sourceDir), silent = TRUE)
# # roxygen2::roxygenize(load_code = sourceDir) # generate documentation
pkgbuild::compile_dll()
roxygen2::roxygenize()
#### Run test scripts
# library(testthat)
devtools::test(stop_on_failure = TRUE)
usethis::use_testthat()
#### Run test scripts
# library(testthat)
devtools::test(stop_on_failure = TRUE)
?devtools::test
testthat::test_file('tests/testthat/testClusteredQuantal.R')
testthat::test_file('tests/testthat/test_dataJose.R.R')
testthat::test_file('tests/testthat/test_dataJose.R')
# example(source)
# try(roxygen2::roxygenize(load_code = sourceDir), silent = TRUE)
# # roxygen2::roxygenize(load_code = sourceDir) # generate documentation
pkgbuild::compile_dll()
roxygen2::roxygenize()
#### Run test scripts
# library(testthat)
devtools::test(stop_on_failure = TRUE)
# rhub::check() # to run R CMD check for different OS
# devtools::build(binary = TRUE) # build binary package for CRAN
devtools::build() # build source package
devtools::check_built(path = '~/GitHub/BMABMDR_0.0.0.9058.tar.gz', cran = T)
library('rstantools')
library('usethis')
library('roxygen2')
# library(dplyr)
# ?rstan_create_package
# rstan_create_package('C:\\Users\\lucp9385\\Documents\\GitHub\\BMABMDR',
# roxygen=T, travis=T, license=T, auto_config=T)
# Set working directory to the new package directory
setwd('C:\\Users\\lucp9385\\Documents\\GitHub\\BMABMDR')
list.files(all.files=T)
# file.show('DESCRIPTION')
# file.show('Read-and-delete-me')
# file.remove('Read-and-delete-me')
## Save all Stan files in the 'inst/stan' subdirectory
# when installing the package these will be saved in the list 'stanmodels' that is used by R to function the package
## All functions to be used by R should be saved in the 'R/' directory
Sys.getenv("BINPREF") # should be "C:/Rtools/mingw64/bin/"
# Sys.setenv(BINPREF = "C:/rtools40/mingw64/bin/;C:/rtools40/mingw32/bin/")
Sys.setenv(BINPREF = "C:/rtools40/mingw64/bin/")
# Sys.setenv(BINPREF = "C:/rtools40/mingw$(WIN)/bin/")
Sys.getenv("PATH")
old_path <- Sys.getenv("PATH")
# new_path <- paste("C:\\Rtools\\usr\\bin", old_path, sep=";")
new_path <- paste(old_path, "C:\\rtools40\\mingw32\\bin;C:\\rtools40\\mingw64\\bin", sep=";")
# # new_path
Sys.setenv(PATH = new_path)
####################################################################################
####################################################################################
### Instructions for publishing a package on CRAN: https://r-pkgs.org/release.html
# https://cran.r-project.org/web/packages/rstantools/vignettes/minimal-rstan-package.html
## Compile package and generate the documentation
rstan_config() # recompile stan models
# example(source)
# try(roxygen2::roxygenize(load_code = sourceDir), silent = TRUE)
# # roxygen2::roxygenize(load_code = sourceDir) # generate documentation
pkgbuild::compile_dll()
roxygen2::roxygenize()
# rhub::check() # to run R CMD check for different OS
# devtools::build(binary = TRUE) # build binary package for CRAN
devtools::build() # build source package
devtools::check_built(path = '~/GitHub/BMABMDR_0.0.0.9058.tar.gz', cran = T)
library('rstantools')
library('usethis')
library('roxygen2')
# library(dplyr)
# ?rstan_create_package
# rstan_create_package('C:\\Users\\lucp9385\\Documents\\GitHub\\BMABMDR',
# roxygen=T, travis=T, license=T, auto_config=T)
# Set working directory to the new package directory
setwd('C:\\Users\\lucp9385\\Documents\\GitHub\\BMABMDR')
list.files(all.files=T)
# file.show('DESCRIPTION')
# file.show('Read-and-delete-me')
# file.remove('Read-and-delete-me')
## Save all Stan files in the 'inst/stan' subdirectory
# when installing the package these will be saved in the list 'stanmodels' that is used by R to function the package
## All functions to be used by R should be saved in the 'R/' directory
Sys.getenv("BINPREF") # should be "C:/Rtools/mingw64/bin/"
# Sys.setenv(BINPREF = "C:/rtools40/mingw64/bin/;C:/rtools40/mingw32/bin/")
Sys.setenv(BINPREF = "C:/rtools40/mingw64/bin/")
# Sys.setenv(BINPREF = "C:/rtools40/mingw$(WIN)/bin/")
Sys.getenv("PATH")
old_path <- Sys.getenv("PATH")
# new_path <- paste("C:\\Rtools\\usr\\bin", old_path, sep=";")
new_path <- paste(old_path, "C:\\rtools40\\mingw32\\bin;C:\\rtools40\\mingw64\\bin", sep=";")
# # new_path
Sys.setenv(PATH = new_path)
####################################################################################
####################################################################################
### Instructions for publishing a package on CRAN: https://r-pkgs.org/release.html
# https://cran.r-project.org/web/packages/rstantools/vignettes/minimal-rstan-package.html
## Compile package and generate the documentation
rstan_config() # recompile stan models
# example(source)
# try(roxygen2::roxygenize(load_code = sourceDir), silent = TRUE)
# # roxygen2::roxygenize(load_code = sourceDir) # generate documentation
pkgbuild::compile_dll()
roxygen2::roxygenize()
# rhub::check() # to run R CMD check for different OS
# devtools::build(binary = TRUE) # build binary package for CRAN
devtools::build() # build source package
devtools::check_built(path = '~/GitHub/BMABMDR_0.0.0.9058.tar.gz', cran = T)
testthat::test_file('tests/testthat/test_errorPlot.R')
devtools::check_built(path = '~/GitHub/BMABMDR_0.0.0.9058.tar.gz', cran = T)
devtools::check_built(path = '~/GitHub/BMABMDR_0.0.0.9058.tar.gz', cran = T)
