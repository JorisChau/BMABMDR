modelFit <- full.laplace_MA_Q_Cov(
data = data.input,
q = q
)
modelFit$summary
# Plots
pt <- basic.plotQ(modelFit, model_name = 'E4_Q')
pt
# Fit without covariate
data.input.Q <- PREP_DATA_QA(data = data.input, q = q, sumstats = T)
modelFit <- full.laplaceQ_MA(data.input.Q, prior.weights = rep(1,8), pvec = c(0.05,0.5,0.95))
modelFit$MA
modelFit$gof_check
dataDir <- '~/GitHub/BMABMDR/data/'
# Read in data
data <- read.csv(file.path(dataDir, "EggShellThickness.csv"))
summ.data <- data.frame(
x = data[,"Exposure"],
y = data[, "Eggshell.Thickness"]
)
# Prepare data
q = 0.05
sumstats = FALSE
sd = TRUE
extended = TRUE  #TRUE
# Uninformative
data_N = PREP_DATA_N(
summ.data,
sumstats = sumstats,
q = q,
sd = sd,
extended = extended
)
data_LN = PREP_DATA_LN(
summ.data,
sumstats = sumstats,
q = q,
sd = sd,
extended = extended
)
data <- read.table(file.path(dataDir, "test_data_cont.txt"), header = T, sep = "\t", dec = ".")
summ.data <- data.frame(
x = data[, "doseN"],
y = data[, "Response"],
s = data[, "Stdev"],
n = data[, "N"]
)
ADRN <- anydoseresponseN(summ.data$x, summ.data$y, summ.data$s, summ.data$n)
ADRLN <- anydoseresponseLN(summ.data$x, summ.data$y, summ.data$s, summ.data$n)
ADRN
ADRLN
## Preparing data
# bmr
q = 0.05
sumstats = TRUE
sd = TRUE
extended = TRUE
# Uninformative
data_N = PREP_DATA_N(
summ.data,
sumstats = sumstats,
q = q,
sd = sd,
prior.d = 'N11',
extended = extended
)
data_LN = PREP_DATA_LN(
summ.data,
sumstats = sumstats,
q = q,
sd = sd,
prior.d = 'N11',
extended = extended
)
data <- read.table(file.path(dataDir, "test_data_cont.txt"), header = T, sep = "\t", dec = ".")
summ.data <- data.frame(
x = data[, "doseN"],
y = data[, "Response"],
s = data[, "Stdev"],
n = data[, "N"]
)
## Preparing data
# bmr
q = 0.05
sumstats = TRUE
sd = TRUE
extended = TRUE
# Uninformative
data_N = PREP_DATA_N(
summ.data,
sumstats = sumstats,
q = q,
sd = sd,
prior.d = 'EPA',
maxy = c(12,12.1,12.5),
extended = extended
)
data_LN = PREP_DATA_LN(
summ.data,
sumstats = sumstats,
q = q,
sd = sd,
prior.d = 'EPA',
maxy = c(12,12.1,12.5),
extended = extended
)
# sampling specification
ndr=30000
nrch=3
nriter=3000
wu=1000
dl=0.8
trd=10
sd=123
# prior model weights
prior.weights = c(rep(1,8), rep(1,8))
pvec = c(0.05,0.5,0.95)
# Fit models
FLBMD=full.laplace_MA(
data_N,
data_LN,
prior.weights,
ndraws=ndr,
seed=123,
pvec=pvec,
plot=F)
# plot output
pFLBMD = plot.BMADR(FLBMD, weight_type = "LP", include_data = T, all = F, title = '', log = F)
pFLBMD$BMDs
pFLBMD$weights
pFLBMD$model_fit_N
pFLBMD$model_fit_LN
pFLBMD$model_fit
pFLBMD$MA_fit
# plot prior vs posterior
plot_prior(FLBMD, data_N$data, "E4_N", parms = T)
SBMD = sampling_MA(data_N, data_LN,
prior.weights,
ndraws=ndr, nrchains=nrch,
nriterations=nriter, warmup=wu, delta=dl,
treedepth=trd, seed=sd, pvec=pvec)
SBMD$w.msg
SBMD$p.msg
# MA estimates
SBMD$MA_bridge_sampling
SBMD$MA_laplace
# convergence & divergence
SBMD$convergence
SBMD$divergences*100 # percentage of iterations that were divergent
# model-specific fit
SBMD$E4_N
# test whether best-fitting model fits wel (BF < 10 means equally well as saturated model; BF > 10 means best fit is better than saturated model)
SBMD$bf
# plot output
pSBMD = plot.BMADR(SBMD, weight_type = "LP", include_data = T, all = F, title = '', log = T)
pSBMD$BMDs
pSBMD$weights
pSBMD$model_fit_N
pSBMD$model_fit_LN
pSBMD$model_fit
pSBMD$MA_fit
summ.data
summ.data$s <- min(summ.data$s)
summ.data
# prior model weights
prior.weights = c(rep(1,8), rep(0,8))
pvec = c(0.05,0.5,0.95)
## Preparing data
# bmr
q = 0.05
sumstats = TRUE
sd = TRUE
extended = TRUE
# Uninformative
data_N = PREP_DATA_N(
summ.data,
sumstats = sumstats,
q = q,
sd = sd,
prior.d = 'EPA',
extended = extended
)
data_LN = PREP_DATA_LN(
summ.data,
sumstats = sumstats,
q = q,
sd = sd,
prior.d = 'EPA',
extended = extended
)
SBMD = sampling_MA(data_N, data_LN,
prior.weights,
ndraws=ndr, nrchains=nrch,
nriterations=nriter, warmup=wu, delta=dl,
treedepth=trd, seed=sd, pvec=pvec)
# plot output
pSBMD = plot.BMADR(SBMD, weight_type = "LP", include_data = T, all = F, title = '', log = T)
pSBMD$model_fit_N
pSBMD$BMDs
pSBMD$model_fit_N
# plot output
pSBMD = plot.BMADR(SBMD, weight_type = "LP", include_data = T, all = F, title = '', log = F)
pSBMD$model_fit_N
pSBMD$model_fit_LN
pSBMD$model_fit
pSBMD$MA_fit
# roxygen2::roxygenize(load_code = sourceDir) # generate documentation
pkgbuild::compile_dll()
roxygen2::roxygenize()
library(BMABMDR)
# plot output
pSBMD = plot.BMADR(SBMD, weight_type = "LP", include_data = T, all = F, title = '', log = F)
pSBMD$MA_fit
dataDir <- '~/GitHub/BMABMDR/data/'
data <- read.csv(file.path(dataDir, "example_clusteredQuantal.csv"))
orderedData <- data[,
c("dose", "y", "n", "litter")
]
anydoseresponseQ(orderedData$dose, orderedData$y, orderedData$n, cluster = T)
argListPrep <- list(
data = orderedData,
q = 0.1,
extended = TRUE,
cluster = TRUE
)
prepData <- do.call("PREP_DATA_QA", argListPrep)
# Fit models
argListFit <- list(
data.Q = prepData,
prior.weights = rep(1,8)
)
modelFit <- do.call("full.laplaceQ_MA", argListFit)
modelFit$w.msg
modelFit$MA
modelFit$gof_check
pFLBMD_Q = plot.BMADRQ(modelFit, weight_type = "LP", include_data = T, all = F, title = '')
pFLBMD_Q$BMDs
pFLBMD_Q$weights
pFLBMD_Q$model_fit
pFLBMD_Q$MA_fit
dataDir <- '~/GitHub/BMABMDR/data/'
load(file.path(file.path(dataDir, "das1.rda")))
indData <- na.omit(das1$data[, c("Dose", "LDH")]) #BW instead of LDH works
argListPrepData <- list(
data = indData,
sumstats = FALSE,
sd = TRUE,
q = 0.05,
extended = TRUE
)
data_N <- do.call("PREP_DATA_N", argListPrepData)
data_LN <-  do.call("PREP_DATA_LN", argListPrepData)
argListFit <- list(
data.N = data_N,
data.LN = data_LN,
prior.weights = rep(1,16)
)
modelFit <- do.call("full.laplace_MA", argListFit)
# modelFit <- do.call("sampling_MA", argListFit)
modelFit$w.msg
modelPlot <- plot.BMADR(
mod.obj = modelFit,
weight_type = "LP",
type = ifelse(argListFit$data.N$data$is_increasing == 1, "increasing", "decreasing"),
title = '', all = F, log = T
)
modelPlot$BMDs
modelPlot$weights
modelPlot$model_fit
modelPlot$model_fit_N
modelPlot$model_fit_LN
modelPlot$MA_fit
summ.data <- argList$data
# Convert to SD if necessary to avoid errors when using functions requiring SD (such as bartlett, NtoLN)
if (argList$sd == FALSE){
summ.data[,3] <- summ.data[,3]*sqrt(summ.data[,4])
argList$sd <- TRUE
argList$data <- summ.data
}
## Bartlett test
# normal distribution
b.Normal <- bartlett(sd = summ.data[,3], n = summ.data[,4])
getAnalysisData <- function(argList, selectedDistribution, pval = 0.05){
summ.data <- argList$data
# Convert to SD if necessary to avoid errors when using functions requiring SD (such as bartlett, NtoLN)
if (argList$sd == FALSE){
summ.data[,3] <- summ.data[,3]*sqrt(summ.data[,4])
argList$sd <- TRUE
argList$data <- summ.data
}
## Bartlett test
# normal distribution
b.Normal <- bartlett(sd = summ.data[,3], n = summ.data[,4])
# lognormal distribution
## Convert arithmetic to geometric summary stats
summ.data.LN <- data.frame(x = summ.data[,1],
y = NtoLN(summ.data[,2], summ.data[,3])[1:length(summ.data[,1])],
s = NtoLN(summ.data[,2], summ.data[,3])[(length(summ.data[,1])+1):(2*length(summ.data[,1]))],
n = summ.data[,4]
)
b.Lognormal <- bartlett(sd = log(summ.data.LN[,3]), n = summ.data.LN[,4])
## Different scenario's depending on outcome of Bartlett test
analysisData <- if (b.Normal[2] >= pval & b.Lognormal[2] >= pval){
# If assumption met for both distributions
data_N <- do.call("PREP_DATA_N", argList)
data_LN <- do.call("PREP_DATA_LN", argList)
prior.weights <- c(rep(1,8), rep(1,8)) # Do analysis for both distributions
list(data = list(
default = list(data_N = data_N, data_LN = data_LN, prior.weights = prior.weights, warning = NULL)
), warning = NULL
)
} else if(b.Normal[2] >= pval & b.Lognormal[2] < pval){
## If assumption met for Normal only
# Data for default analyses with Normal only
data_N = do.call("PREP_DATA_N", argList)
data_LN = do.call("PREP_DATA_LN", argList)
## Data for sensitivity analysis
summ.data.LN.sens1 <- summ.data.LN
summ.data.LN.sens1$s <- min(summ.data.LN.sens1$s) # minimum geometric sd
argList$data <- summ.data.LN.sens1
argList <- append(argList, list(geom.stats = T)) # specify that geometric summary stats are given as input
data_LN_sens1 <- do.call("PREP_DATA_LN", argList)
summ.data.LN.sens2 <- summ.data.LN
summ.data.LN.sens2$s <- max(summ.data.LN.sens2$s) # maximum geometric sd
argList$data <- summ.data.LN.sens2
data_LN_sens2 <- do.call("PREP_DATA_LN", argList)
# Make sublists per scenario
list(data = list(
default = list(data_N = data_N, data_LN = data_LN, prior.weights = c(rep(1,8), rep(1,8))),
defaultAdaptedWeights = list(data_N = data_N, data_LN = data_LN, prior.weights = c(rep(1,8), rep(0,8))),  # set weights to 0 for Lognormal
minVar = list(data_N = data_N, data_LN = data_LN_sens1, prior.weights = c(rep(1,8), rep(1,8))),
maxVar = list(data_N = data_N, data_LN = data_LN_sens2, prior.weights = c(rep(1,8), rep(1,8)))
), warning = NULL
)
} else if(b.Normal[2] < pval & b.Lognormal[2] >= pval){
## If assumption met for Lognormal only
# Data for default analyses with Lognormal only
data_N = do.call("PREP_DATA_N", argList)
data_LN = do.call("PREP_DATA_LN", argList)
## Data for sensitivity analyses
summ.data.N.sens1 <- summ.data
summ.data.N.sens1$s <- min(summ.data$s) # minimum arithmetic sd
argList$data <- summ.data.N.sens1
data_N_sens1 = do.call("PREP_DATA_N", argList)
summ.data.N.sens2 <- summ.data
summ.data.N.sens2$s <- max(summ.data$s) # maximum arithmetic sd
argList$data <- summ.data.N.sens2
data_N_sens2 = do.call("PREP_DATA_N", argList)
list(data = list(
default = list(data_N = data_N, data_LN = data_LN, prior.weights = c(rep(1,8), rep(1,8))),
defaultAdaptedWeights = list(data_N = data_N, data_LN = data_LN, prior.weights = c(rep(0,8), rep(1,8))),  # set weights to 0 for Normal
minVar = list(data_N = data_N_sens1, data_LN = data_LN, prior.weights = c(rep(1,8), rep(1,8))),
maxVar = list(data_N = data_N_sens2, data_LN = data_LN, prior.weights = c(rep(1,8), rep(1,8)))
), warning = NULL
)
} else if(b.Normal[2] < pval & b.Lognormal[2] < pval){
## If assumption met for none
# Data for regular analyses with both distributions, but warning should be given about violation of assumptions
data_N = do.call("PREP_DATA_N", argList)
data_LN = do.call("PREP_DATA_LN", argList)
# Data for analysis with smallest SD
summ.data.N.sens1 <- summ.data
summ.data.N.sens1$s <- min(summ.data$s)
argList$data <- summ.data.N.sens1
data_N_sens1 = do.call("PREP_DATA_N", argList)
summ.data.LN.sens1 <- summ.data.LN
summ.data.LN.sens1$s <- min(summ.data.LN.sens1$s)
argList$data <- summ.data.LN.sens1
argList <- append(argList, list(geom.stats = T)) # specify that geometric summary stats are given as input
data_LN_sens1 <- do.call("PREP_DATA_LN", argList)
# Data for analysis with largest SD
summ.data.N.sens2 <- summ.data
summ.data.N.sens2$s <- max(summ.data.N.sens2$s)
argList$geom.stats = FALSE # revert back to false for normal data
argList$data <- summ.data.N.sens2
data_N_sens2 = do.call("PREP_DATA_N", argList)
summ.data.LN.sens2 <- summ.data.LN
summ.data.LN.sens2$s <- max(summ.data.LN.sens2$s)
argList$data <- summ.data.LN.sens2
argList$geom.stats = TRUE # specify that geometric summary stats are given as input
data_LN_sens2 <- do.call("PREP_DATA_LN", argList)
list(data = list(
default = list(data_N = data_N, data_LN = data_LN, prior.weights = c(rep(1,8), rep(1,8))),
minVar = list(data_N = data_N_sens1, data_LN = data_LN_sens1, prior.weights = c(rep(1,8), rep(1,8))),
maxVar = list(data_N = data_N_sens2, data_LN = data_LN_sens2, prior.weights = c(rep(1,8), rep(1,8)))
), warning = TRUE
)
}
# Remove defaultAdaptedWeights scenario if any Distribution type has been unchecked
if (length(selectedDistribution) < 2){
analysisData$data$defaultAdaptedWeights <- NULL
}
return(analysisData)
}
dataDir <- '~/GitHub/BMABMDR/data/'
data <- read.table(file.path(dataDir, "test_data_cont.txt"), header = T, sep = "\t", dec = ".")
summ.data <- data.frame(
x = data[, "doseN"],
y = data[, "Response"],
s = data[, "Stdev"],
n = data[, "N"]
)
## Preparing data
# bmr
argList = list(
data = summ.data,
q = 0.05,
sumstats = TRUE,
sd = TRUE,
extended = TRUE,
prior.d = 'N11'
)
# Perform sensitivity analyses
analysisData <- getAnalysisData(
argList = argList,
selectedDistribution = "Lognormal"
)
## Fit models
# sampling specification
ndraws = 30000
seed = 123
# prior model weights
prior.weights = c(rep(0,8), rep(1,8))
pvec = c(0.05,0.5,0.95)
# Fit models
FLBMD = full.laplace_MA(
data.N = analysisData$data$minVar$data_N,
data.LN = analysisData$data$minVar$data_LN,
prior.weights = prior.weights,
ndraws = ndraws,
seed = seed,
pvec = pvec
)
summary.BMADR(FLBMD)
FLBMD$p.msg
## Create plots
pFLBMD = plot.BMADR(
mod.obj = FLBMD,
weight_type = "LP",
log = FALSE,
include_data = TRUE,
all = FALSE,
title = ''
)
pFLBMD$model_fit_N
pFLBMD$model_fit_LN
pFLBMD$MA_fit
SBMD = sampling_MA(
data.N = analysisData$data$minVar$data_N,
data.LN = analysisData$data$minVar$data_LN,
prior.weights = prior.weights,
ndraws = ndraws,
seed = seed,
pvec = pvec
)
summary.BMADR(SBMD)
SBMD$p.msg
pSBMD = plot.BMADR(SBMD, 'increasing', weight_type = 'BS', all = F)
pSBMD = plot.BMADR(SBMD, 'increasing', weight_type = 'BS', all = F, title = '')
pSBMD$MA_fit
# Load data
summ.data <- read.csv(file.path(dataDir,'examplecontinuouswithcovariate.csv'))
# Subset data
summ.data <- summ.data[summ.data$Covariate == "Male", c("Dose", "Response3", "SD", "N")]
# Argument list
argList <- list(
data = summ.data,
sumstats = TRUE,
sd = TRUE,
q = 0.1
)
# Bartlett test
## normal distribution
b.Normal <- bartlett(sd = summ.data[,3], n = summ.data[,4])
## lognormal distribution
### Convert arithmetic to geometric summary stats
summ.data.LN <- data.frame(x = summ.data[,1],
y = NtoLN(summ.data[,2], summ.data[,3])[1:length(summ.data[,1])],
s = NtoLN(summ.data[,2], summ.data[,3])[(length(summ.data[,1])+1):(2*length(summ.data[,1]))],
n = summ.data[,4]
)
b.Lognormal <- bartlett(sd = log(summ.data.LN[,3]), n = summ.data.LN[,4])
# Data for default analyses
data_N = do.call("PREP_DATA_N", argList)
data_LN = do.call("PREP_DATA_LN", argList)
## Data for sensitivity analysis
summ.data.LN.sens1 <- summ.data.LN
summ.data.LN.sens1$s <- min(summ.data.LN.sens1$s) # minimum geometric sd
argList$data <- summ.data.LN.sens1
argList <- append(argList, list(geom.stats = T)) # specify that geometric summary stats are given as input
data_LN_sens1 <- do.call("PREP_DATA_LN", argList)
summ.data.LN.sens2 <- summ.data.LN
summ.data.LN.sens2$s <- max(summ.data.LN.sens2$s) # maximum geometric sd
argList$data <- summ.data.LN.sens2
data_LN_sens2 <- do.call("PREP_DATA_LN", argList)
analysisData <- list(data = list(
default = list(data_N = data_N, data_LN = data_LN, prior.weights = c(rep(1,8), rep(1,8))),
defaultAdaptedWeights = list(data_N = data_N, data_LN = data_LN, prior.weights = c(rep(1,8), rep(0,8))),  # set weights to 0 for Lognormal
minVar = list(data_N = data_N, data_LN = data_LN_sens1, prior.weights = c(rep(1,8), rep(1,8))),
maxVar = list(data_N = data_N, data_LN = data_LN_sens2, prior.weights = c(rep(1,8), rep(1,8)))
), warning = NULL
)
# Fit models
argListFit <- list(
data.N = analysisData$data$minVar$data_N,
data.LN = analysisData$data$minVar$data_LN,
prior.weights = c(rep(0,8), rep(1,8)),
ndraws = 30000
)
fittedModels <- do.call("full.laplace_MA", argListFit)
modelSummary <- summary.BMADR(fittedModels, type = "continuous")
modelSummary$BMDWeights
